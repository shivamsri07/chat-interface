"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ai/node_modules/nanoid/non-secure/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZvaWNlLWNoYXRib3QvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzP2RhMWUiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplID0gMjEpID0+IHtcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIGxldCBpID0gc2l6ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlkICs9IGFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoKSB8IDBdXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9XG59XG5sZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSAnJ1xuICBsZXQgaSA9IHNpemVcbiAgd2hpbGUgKGktLSkge1xuICAgIGlkICs9IHVybEFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogNjQpIHwgMF1cbiAgfVxuICByZXR1cm4gaWRcbn1cbmV4cG9ydCB7IG5hbm9pZCwgY3VzdG9tQWxwaGFiZXQgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useAssistant: () => (/* binding */ useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/generate-id.ts\n\nvar generateId = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallsStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"9\",\n    name: \"tool_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n            throw new Error('\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.');\n        }\n        return {\n            type: \"tool_call\",\n            value\n        };\n    }\n};\nvar toolResultStreamPart = {\n    code: \"a\",\n    name: \"tool_result\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\" || !(\"result\" in value)) {\n            throw new Error('\"tool_result\" parts expect an object with a \"toolCallId\", \"toolName\", \"args\", and \"result\" property.');\n        }\n        return {\n            type: \"tool_result\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallsStreamPart,\n    messageAnnotationsStreamPart,\n    toolCallStreamPart,\n    toolResultStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallsStreamPart.code]: toolCallsStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [toolResultStreamPart.code]: toolResultStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallsStreamPart.name]: toolCallsStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [toolResultStreamPart.name]: toolResultStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function parseComplexResponse({ reader, abortControllerRef, update, onToolCall, onFinish, generateId: generateId2 = generateId, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    let message_annotations = void 0;\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        if (type === \"tool_call\") {\n            if (prefixMap.text == null) {\n                prefixMap.text = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: \"\",\n                    createdAt\n                };\n            }\n            if (prefixMap.text.toolInvocations == null) {\n                prefixMap.text.toolInvocations = [];\n            }\n            prefixMap.text.toolInvocations.push(value);\n            if (onToolCall) {\n                const result = await onToolCall({\n                    toolCall: value\n                });\n                if (result != null) {\n                    prefixMap.text.toolInvocations[prefixMap.text.toolInvocations.length - 1] = {\n                        ...value,\n                        result\n                    };\n                }\n            }\n        } else if (type === \"tool_result\") {\n            if (prefixMap.text == null) {\n                prefixMap.text = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: \"\",\n                    createdAt\n                };\n            }\n            if (prefixMap.text.toolInvocations == null) {\n                prefixMap.text.toolInvocations = [];\n            }\n            const toolInvocationIndex = prefixMap.text.toolInvocations.findIndex((invocation)=>invocation.toolCallId === value.toolCallId);\n            if (toolInvocationIndex !== -1) {\n                prefixMap.text.toolInvocations[toolInvocationIndex] = value;\n            } else {\n                prefixMap.text.toolInvocations.push(value);\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!message_annotations) {\n                message_annotations = [\n                    ...value\n                ];\n            } else {\n                message_annotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], message_annotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], message_annotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], message_annotations);\n        }\n        if (message_annotations == null ? void 0 : message_annotations.length) {\n            const messagePrefixKeys = [\n                \"text\",\n                \"function_call\",\n                \"tool_calls\"\n            ];\n            messagePrefixKeys.forEach((key)=>{\n                if (prefixMap[key]) {\n                    prefixMap[key].annotations = [\n                        ...message_annotations\n                    ];\n                }\n            });\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, message_annotations)\n            }));\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// shared/call-chat-api.ts\nasync function callChatApi({ api, messages, body, streamMode = \"stream-data\", credentials, headers, abortController, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, onToolCall, generateId: generateId2 }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    switch(streamMode){\n        case \"text\":\n            {\n                const decoder = createChunkDecoder();\n                const resultMessage = {\n                    id: generateId2(),\n                    createdAt: /* @__PURE__ */ new Date(),\n                    role: \"assistant\",\n                    content: \"\"\n                };\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    resultMessage.content += decoder(value);\n                    resultMessage.id = generateId2();\n                    onUpdate([\n                        {\n                            ...resultMessage\n                        }\n                    ], []);\n                    if ((abortController == null ? void 0 : abortController()) === null) {\n                        reader.cancel();\n                        break;\n                    }\n                }\n                onFinish == null ? void 0 : onFinish(resultMessage);\n                return {\n                    messages: [\n                        resultMessage\n                    ],\n                    data: []\n                };\n            }\n        case \"stream-data\":\n            {\n                return await parseComplexResponse({\n                    reader,\n                    abortControllerRef: abortController != null ? {\n                        current: abortController()\n                    } : void 0,\n                    update: onUpdate,\n                    onToolCall,\n                    onFinish (prefixMap) {\n                        if (onFinish && prefixMap.text != null) {\n                            onFinish(prefixMap.text);\n                        }\n                    },\n                    generateId: generateId2\n                });\n            }\n        default:\n            {\n                const exhaustiveCheck = streamMode;\n                throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n            }\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, onToolCall, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, data, annotations, toolInvocations, function_call, tool_calls, tool_call_id })=>({\n            role,\n            content,\n            ...name !== void 0 && {\n                name\n            },\n            ...data !== void 0 && {\n                data\n            },\n            ...annotations !== void 0 && {\n                annotations\n            },\n            ...toolInvocations !== void 0 && {\n                toolInvocations\n            },\n            // outdated function/tool call handling (TODO deprecate):\n            tool_call_id,\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tool_calls !== void 0 && {\n                tool_calls\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = generateId2();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callChatApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            },\n            ...chatRequest.tools !== void 0 && {\n                tools: chatRequest.tools\n            },\n            ...chatRequest.tool_choice !== void 0 && {\n                tool_choice: chatRequest.tool_choice\n            }\n        },\n        streamMode,\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onToolCall,\n        onFinish,\n        generateId: generateId2\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, experimental_onToolCall, onToolCall, experimental_maxAutomaticRoundtrips = 0, maxAutomaticRoundtrips = experimental_maxAutomaticRoundtrips, maxToolRoundtrips = maxAutomaticRoundtrips, streamMode, onResponse, onFinish, onError, credentials, headers, body, generateId: generateId2 = generateId } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const idKey = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        idKey\n    ] : idKey;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamMode, onFinish, onResponse, onToolCall, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                experimental_onToolCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n        const messages2 = messagesRef.current;\n        const lastMessage = messages2[messages2.length - 1];\n        if (// ensure there is a last message:\n        lastMessage != null && // check if the feature is enabled:\n        maxToolRoundtrips > 0 && // check that roundtrip is possible:\n        isAssistantMessageWithCompletedToolCalls(lastMessage) && // limit the number of automatic roundtrips:\n        countTrailingAssistantMessages(messages2) <= maxToolRoundtrips) {\n            await triggerRequest({\n                messages: messages2\n            });\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        streamMode,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        onToolCall,\n        maxToolRoundtrips,\n        messagesRef,\n        abortControllerRef,\n        generateId2\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, tools, tool_choice, data } = {})=>{\n        if (!message.id) {\n            message.id = generateId2();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId2\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call, tools, tool_choice } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                },\n                ...tools !== void 0 && {\n                    tools\n                },\n                ...tool_choice !== void 0 && {\n                    tool_choice\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    const addToolResult = ({ toolCallId, result })=>{\n        const updatedMessages = messagesRef.current.map((message, index, arr)=>// update the tool calls in the last assistant message:\n            index === arr.length - 1 && message.role === \"assistant\" && message.toolInvocations ? {\n                ...message,\n                toolInvocations: message.toolInvocations.map((toolInvocation)=>toolInvocation.toolCallId === toolCallId ? {\n                        ...toolInvocation,\n                        result\n                    } : toolInvocation)\n            } : message);\n        mutate(updatedMessages, false);\n        const lastMessage = updatedMessages[updatedMessages.length - 1];\n        if (isAssistantMessageWithCompletedToolCalls(lastMessage)) {\n            triggerRequest({\n                messages: updatedMessages\n            });\n        }\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData,\n        addToolResult,\n        experimental_addToolResult: addToolResult\n    };\n}\nfunction isAssistantMessageWithCompletedToolCalls(message) {\n    return message.role === \"assistant\" && message.toolInvocations && message.toolInvocations.length > 0 && message.toolInvocations.every((toolInvocation)=>\"result\" in toolInvocation);\n}\nfunction countTrailingAssistantMessages(messages) {\n    let count = 0;\n    for(let i = messages.length - 1; i >= 0; i--){\n        if (messages[i].role === \"assistant\") {\n            count++;\n        } else {\n            break;\n        }\n    }\n    return count;\n}\n// react/use-completion.ts\n\n\n// shared/call-completion-api.ts\nasync function callCompletionApi({ api, prompt, credentials, headers, body, streamMode = \"stream-data\", setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData }) {\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        switch(streamMode){\n            case \"text\":\n                {\n                    const decoder = createChunkDecoder();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        result += decoder(value);\n                        setCompletion(result);\n                        if (abortController === null) {\n                            reader.cancel();\n                            break;\n                        }\n                    }\n                    break;\n                }\n            case \"stream-data\":\n                {\n                    for await (const { type, value } of readDataStream(reader, {\n                        isAborted: ()=>abortController === null\n                    })){\n                        switch(type){\n                            case \"text\":\n                                {\n                                    result += value;\n                                    setCompletion(result);\n                                    break;\n                                }\n                            case \"data\":\n                                {\n                                    onData == null ? void 0 : onData(value);\n                                    break;\n                                }\n                        }\n                    }\n                    break;\n                }\n            default:\n                {\n                    const exhaustiveCheck = streamMode;\n                    throw new Error(`Unknown stream mode: ${exhaustiveCheck}`);\n                }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// react/use-completion.ts\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, streamMode, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>callCompletionApi({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            streamMode,\n            setCompletion: (completion2)=>mutate(completion2, false),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError,\n            onData: (data2)=>{\n                mutateStreamData([\n                    ...streamData || [],\n                    ...data2 || []\n                ], false);\n            }\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        streamMode,\n        mutateStreamData\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-assistant.ts\n\n\nfunction useAssistant({ api, threadId: threadIdParam, credentials, headers, body, onError }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const append = async (message, requestOptions)=>{\n        var _a;\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>{\n            var _a2;\n            return [\n                ...messages2,\n                {\n                    ...message,\n                    id: (_a2 = message.id) != null ? _a2 : generateId()\n                }\n            ];\n        });\n        setInput(\"\");\n        const abortController = new AbortController();\n        try {\n            abortControllerRef.current = abortController;\n            const result = await fetch(api, {\n                method: \"POST\",\n                credentials,\n                signal: abortController.signal,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...headers\n                },\n                body: JSON.stringify({\n                    ...body,\n                    // always use user-provided threadId when available:\n                    threadId: (_a = threadIdParam != null ? threadIdParam : threadId) != null ? _a : null,\n                    message: message.content,\n                    // optional request data:\n                    data: requestOptions == null ? void 0 : requestOptions.data\n                })\n            });\n            if (result.body == null) {\n                throw new Error(\"The response body is empty.\");\n            }\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"text\":\n                        {\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    {\n                                        id: lastMessage.id,\n                                        role: lastMessage.role,\n                                        content: lastMessage.content + value\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"data_message\":\n                        {\n                            setMessages((messages2)=>{\n                                var _a2;\n                                return [\n                                    ...messages2,\n                                    {\n                                        id: (_a2 = value.id) != null ? _a2 : generateId(),\n                                        role: \"data\",\n                                        content: \"\",\n                                        data: value.data\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            setError(new Error(value));\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_3__.isAbortError)(error2) && abortController.signal.aborted) {\n                abortControllerRef.current = null;\n                return;\n            }\n            if (onError && error2 instanceof Error) {\n                onError(error2);\n            }\n            setError(error2);\n        } finally{\n            abortControllerRef.current = null;\n            setStatus(\"awaiting_message\");\n        }\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        append({\n            role: \"user\",\n            content: input\n        }, requestOptions);\n    };\n    return {\n        append,\n        messages,\n        setMessages,\n        threadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error,\n        stop\n    };\n}\nvar experimental_useAssistant = useAssistant;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWdFO0FBQzNCOztBQ0ROO0FBS3hCLElBQU1PLGFBQWFELGlFQUFjQSxDQUN0QyxrRUFDQTs7QUNVRixJQUFNRSxpQkFBa0Q7SUFDdERDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQVFGO1FBQU07SUFDL0I7QUFDRjtBQUVBLElBQU1HLHlCQUlGO0lBQ0ZOLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUNDO1FBQ04sSUFDRUEsU0FBUyxRQUNULE9BQU9BLFVBQVUsWUFDakIsQ0FBRSxvQkFBbUJBLEtBQUEsS0FDckIsT0FBT0EsTUFBTUksYUFBQSxLQUFrQixZQUMvQkosTUFBTUksYUFBQSxJQUFpQixRQUN2QixDQUFFLFdBQVVKLE1BQU1JLGFBQUEsS0FDbEIsQ0FBRSxnQkFBZUosTUFBTUksYUFBQSxLQUN2QixPQUFPSixNQUFNSSxhQUFBLENBQWNOLElBQUEsS0FBUyxZQUNwQyxPQUFPRSxNQUFNSSxhQUFBLENBQWNDLFNBQUEsS0FBYyxVQUN6QztZQUNBLE1BQU0sSUFBSUosTUFDUjtRQUVKO1FBRUEsT0FBTztZQUNMQyxNQUFNO1lBQ05GO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsSUFBTU0saUJBQTREO0lBQ2hFVCxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksQ0FBQ08sTUFBTUMsT0FBQSxDQUFRUixRQUFRO1lBQ3pCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUVBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFFQSxJQUFNUyxrQkFBb0Q7SUFDeERaLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUND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QSxDQUFBSjtRQUVBLElBQUlqQyxVQUFVLElBQUk7WUFDaEI7UUFDRjtRQUVBTixPQUFPO1lBQUVoTCxNQUFNO1lBQVFDLFNBQVNxTDtRQUFNLEdBQUdrQztJQUMzQztJQUVBLE9BQU87UUFDTHhDO1FBQ0F2RjtRQUNBNEY7UUFDQS9LO1FBQ0FnTDtRQUNBQztRQUNBSTtRQUNBK0I7UUFDQUw7UUFDQTdDO1FBQ0FXO0lBQ0Y7QUFDRjtBQUtPLElBQU15Qyw0QkFBNEJWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdm9pY2UtY2hhdGJvdC8uLi91c2UtY2hhdC50cz84ODI4Iiwid2VicGFjazovL3ZvaWNlLWNoYXRib3QvLi4vLi4vc2hhcmVkL2dlbmVyYXRlLWlkLnRzPzBkNWYiLCJ3ZWJwYWNrOi8vdm9pY2UtY2hhdGJvdC8uLi8uLi9zaGFyZWQvc3RyZWFtLXBhcnRzLnRzP2M0YTgiLCJ3ZWJwYWNrOi8vdm9pY2UtY2hhdGJvdC8uLi8uLi9zaGFyZWQvcmVhZC1kYXRhLXN0cmVhbS50cz8xOGYxIiwid2VicGFjazovL3ZvaWNlLWNoYXRib3QvLi4vLi4vc2hhcmVkL3BhcnNlLWNvbXBsZXgtcmVzcG9uc2UudHM/NjVlMCIsIndlYnBhY2s6Ly92b2ljZS1jaGF0Ym90Ly4uLy4uL3NoYXJlZC91dGlscy50cz9mOGNmIiwid2VicGFjazovL3ZvaWNlLWNoYXRib3QvLi4vLi4vc2hhcmVkL2NhbGwtY2hhdC1hcGkudHM/YjU1YiIsIndlYnBhY2s6Ly92b2ljZS1jaGF0Ym90Ly4uLy4uL3NoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtLnRzPzhkN2YiLCJ3ZWJwYWNrOi8vdm9pY2UtY2hhdGJvdC8uLi91c2UtY29tcGxldGlvbi50cz9hZTdmIiwid2VicGFjazovL3ZvaWNlLWNoYXRib3QvLi4vLi4vc2hhcmVkL2NhbGwtY29tcGxldGlvbi1hcGkudHM/ODUyNSIsIndlYnBhY2s6Ly92b2ljZS1jaGF0Ym90Ly4uL3VzZS1hc3Npc3RhbnQudHM/MjgxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTV1IsIHsgS2V5ZWRNdXRhdG9yIH0gZnJvbSAnc3dyJztcbmltcG9ydCB7IGNhbGxDaGF0QXBpIH0gZnJvbSAnLi4vc2hhcmVkL2NhbGwtY2hhdC1hcGknO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuYyB9IGZyb20gJy4uL3NoYXJlZC9nZW5lcmF0ZS1pZCc7XG5pbXBvcnQgeyBwcm9jZXNzQ2hhdFN0cmVhbSB9IGZyb20gJy4uL3NoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtJztcbmltcG9ydCB0eXBlIHtcbiAgQ2hhdFJlcXVlc3QsXG4gIENoYXRSZXF1ZXN0T3B0aW9ucyxcbiAgQ3JlYXRlTWVzc2FnZSxcbiAgSWRHZW5lcmF0b3IsXG4gIEpTT05WYWx1ZSxcbiAgTWVzc2FnZSxcbiAgVXNlQ2hhdE9wdGlvbnMsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlYWN0UmVzcG9uc2VSb3csXG4gIGV4cGVyaW1lbnRhbF9TdHJlYW1pbmdSZWFjdFJlc3BvbnNlLFxufSBmcm9tICcuLi9zdHJlYW1zL3N0cmVhbWluZy1yZWFjdC1yZXNwb25zZSc7XG5cbmV4cG9ydCB0eXBlIHsgQ3JlYXRlTWVzc2FnZSwgTWVzc2FnZSwgVXNlQ2hhdE9wdGlvbnMgfTtcblxuZXhwb3J0IHR5cGUgVXNlQ2hhdEhlbHBlcnMgPSB7XG4gIC8qKiBDdXJyZW50IG1lc3NhZ2VzIGluIHRoZSBjaGF0ICovXG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIC8qKiBUaGUgZXJyb3Igb2JqZWN0IG9mIHRoZSBBUEkgcmVxdWVzdCAqL1xuICBlcnJvcjogdW5kZWZpbmVkIHwgRXJyb3I7XG4gIC8qKlxuICAgKiBBcHBlbmQgYSB1c2VyIG1lc3NhZ2UgdG8gdGhlIGNoYXQgbGlzdC4gVGhpcyB0cmlnZ2VycyB0aGUgQVBJIGNhbGwgdG8gZmV0Y2hcbiAgICogdGhlIGFzc2lzdGFudCdzIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBhcHBlbmRcbiAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSSBjYWxsXG4gICAqL1xuICBhcHBlbmQ6IChcbiAgICBtZXNzYWdlOiBNZXNzYWdlIHwgQ3JlYXRlTWVzc2FnZSxcbiAgICBjaGF0UmVxdWVzdE9wdGlvbnM/OiBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIFJlbG9hZCB0aGUgbGFzdCBBSSBjaGF0IHJlc3BvbnNlIGZvciB0aGUgZ2l2ZW4gY2hhdCBoaXN0b3J5LiBJZiB0aGUgbGFzdFxuICAgKiBtZXNzYWdlIGlzbid0IGZyb20gdGhlIGFzc2lzdGFudCwgaXQgd2lsbCByZXF1ZXN0IHRoZSBBUEkgdG8gZ2VuZXJhdGUgYVxuICAgKiBuZXcgcmVzcG9uc2UuXG4gICAqL1xuICByZWxvYWQ6IChcbiAgICBjaGF0UmVxdWVzdE9wdGlvbnM/OiBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIEFib3J0IHRoZSBjdXJyZW50IHJlcXVlc3QgaW1tZWRpYXRlbHksIGtlZXAgdGhlIGdlbmVyYXRlZCB0b2tlbnMgaWYgYW55LlxuICAgKi9cbiAgc3RvcDogKCkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYG1lc3NhZ2VzYCBzdGF0ZSBsb2NhbGx5LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvXG4gICAqIGVkaXQgdGhlIG1lc3NhZ2VzIG9uIHRoZSBjbGllbnQsIGFuZCB0aGVuIHRyaWdnZXIgdGhlIGByZWxvYWRgIG1ldGhvZFxuICAgKiBtYW51YWxseSB0byByZWdlbmVyYXRlIHRoZSBBSSByZXNwb25zZS5cbiAgICovXG4gIHNldE1lc3NhZ2VzOiAobWVzc2FnZXM6IE1lc3NhZ2VbXSkgPT4gdm9pZDtcbiAgLyoqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICBpbnB1dDogc3RyaW5nO1xuICAvKiogc2V0U3RhdGUtcG93ZXJlZCBtZXRob2QgdG8gdXBkYXRlIHRoZSBpbnB1dCB2YWx1ZSAqL1xuICBzZXRJbnB1dDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nPj47XG4gIC8qKiBBbiBpbnB1dC90ZXh0YXJlYS1yZWFkeSBvbkNoYW5nZSBoYW5kbGVyIHRvIGNvbnRyb2wgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICBoYW5kbGVJbnB1dENoYW5nZTogKFxuICAgIGU6XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICApID0+IHZvaWQ7XG4gIC8qKiBGb3JtIHN1Ym1pc3Npb24gaGFuZGxlciB0byBhdXRvbWF0aWNhbGx5IHJlc2V0IGlucHV0IGFuZCBhcHBlbmQgYSB1c2VyIG1lc3NhZ2UgKi9cbiAgaGFuZGxlU3VibWl0OiAoXG4gICAgZTogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4sXG4gICAgY2hhdFJlcXVlc3RPcHRpb25zPzogQ2hhdFJlcXVlc3RPcHRpb25zLFxuICApID0+IHZvaWQ7XG4gIG1ldGFkYXRhPzogT2JqZWN0O1xuICAvKiogV2hldGhlciB0aGUgQVBJIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MgKi9cbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICAvKiogQWRkaXRpb25hbCBkYXRhIGFkZGVkIG9uIHRoZSBzZXJ2ZXIgdmlhIFN0cmVhbURhdGEgKi9cbiAgZGF0YT86IEpTT05WYWx1ZVtdO1xufTtcblxuLyoqXG5AZGVwcmVjYXRlZCBVc2UgQUkgU0RLIFJTQyBpbnN0ZWFkOiBodHRwczovL3Nkay52ZXJjZWwuYWkvZG9jcy9haS1zZGstcnNjXG4gKi9cbnR5cGUgU3RyZWFtaW5nUmVhY3RSZXNwb25zZUFjdGlvbiA9IChwYXlsb2FkOiB7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xufSkgPT4gUHJvbWlzZTxleHBlcmltZW50YWxfU3RyZWFtaW5nUmVhY3RSZXNwb25zZT47XG5cbmNvbnN0IGdldFN0cmVhbWVkUmVzcG9uc2UgPSBhc3luYyAoXG4gIGFwaTogc3RyaW5nIHwgU3RyZWFtaW5nUmVhY3RSZXNwb25zZUFjdGlvbixcbiAgY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0LFxuICBtdXRhdGU6IEtleWVkTXV0YXRvcjxNZXNzYWdlW10+LFxuICBtdXRhdGVTdHJlYW1EYXRhOiBLZXllZE11dGF0b3I8SlNPTlZhbHVlW10gfCB1bmRlZmluZWQ+LFxuICBleGlzdGluZ0RhdGE6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkLFxuICBleHRyYU1ldGFkYXRhUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PGFueT4sXG4gIG1lc3NhZ2VzUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE1lc3NhZ2VbXT4sXG4gIGFib3J0Q29udHJvbGxlclJlZjogUmVhY3QuTXV0YWJsZVJlZk9iamVjdDxBYm9ydENvbnRyb2xsZXIgfCBudWxsPixcbiAgZ2VuZXJhdGVJZDogSWRHZW5lcmF0b3IsXG4gIHN0cmVhbU1vZGU/OiAnc3RyZWFtLWRhdGEnIHwgJ3RleHQnLFxuICBvbkZpbmlzaD86IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkLFxuICBvblJlc3BvbnNlPzogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD4sXG4gIG9uVG9vbENhbGw/OiBVc2VDaGF0T3B0aW9uc1snb25Ub29sQ2FsbCddLFxuICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzPzogYm9vbGVhbixcbikgPT4ge1xuICAvLyBEbyBhbiBvcHRpbWlzdGljIHVwZGF0ZSB0byB0aGUgY2hhdCBzdGF0ZSB0byBzaG93IHRoZSB1cGRhdGVkIG1lc3NhZ2VzXG4gIC8vIGltbWVkaWF0ZWx5LlxuICBjb25zdCBwcmV2aW91c01lc3NhZ2VzID0gbWVzc2FnZXNSZWYuY3VycmVudDtcbiAgbXV0YXRlKGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBmYWxzZSk7XG5cbiAgY29uc3QgY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQgPSBzZW5kRXh0cmFNZXNzYWdlRmllbGRzXG4gICAgPyBjaGF0UmVxdWVzdC5tZXNzYWdlc1xuICAgIDogY2hhdFJlcXVlc3QubWVzc2FnZXMubWFwKFxuICAgICAgICAoe1xuICAgICAgICAgIHJvbGUsXG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgdG9vbEludm9jYXRpb25zLFxuICAgICAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgdG9vbF9jYWxscyxcbiAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgcm9sZSxcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIC4uLihuYW1lICE9PSB1bmRlZmluZWQgJiYgeyBuYW1lIH0pLFxuICAgICAgICAgIC4uLihkYXRhICE9PSB1bmRlZmluZWQgJiYgeyBkYXRhIH0pLFxuICAgICAgICAgIC4uLihhbm5vdGF0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHsgYW5ub3RhdGlvbnMgfSksXG4gICAgICAgICAgLi4uKHRvb2xJbnZvY2F0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbEludm9jYXRpb25zIH0pLFxuICAgICAgICAgIC8vIG91dGRhdGVkIGZ1bmN0aW9uL3Rvb2wgY2FsbCBoYW5kbGluZyAoVE9ETyBkZXByZWNhdGUpOlxuICAgICAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgICAgICAuLi4oZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25fY2FsbCB9KSxcbiAgICAgICAgICAuLi4odG9vbF9jYWxscyAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbF9jYWxscyB9KSxcbiAgICAgICAgfSksXG4gICAgICApO1xuXG4gIC8vIFRPRE8gZGVwcmVjYXRlZCwgcmVtb3ZlIGluIG5leHQgbWFqb3IgcmVsZWFzZVxuICBpZiAodHlwZW9mIGFwaSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGFyZSBoYW5kbGluZyBhIFNlcnZlciBBY3Rpb24uIE5vIGNvbXBsZXggbW9kZSBoYW5kbGluZyBuZWVkZWQuXG5cbiAgICBjb25zdCByZXBseUlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgIGlkOiByZXBseUlkLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgY29udGVudDogJycsXG4gICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICB9O1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZFJvdyhwcm9taXNlOiBQcm9taXNlPFJlYWN0UmVzcG9uc2VSb3c+KSB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIHVpLCBuZXh0IH0gPSBhd2FpdCBwcm9taXNlO1xuXG4gICAgICAvLyBUT0RPOiBIYW5kbGUgZnVuY3Rpb24gY2FsbHMuXG4gICAgICByZXNwb25zZU1lc3NhZ2VbJ2NvbnRlbnQnXSA9IGNvbnRlbnQ7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbJ3VpJ10gPSBhd2FpdCB1aTtcblxuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgeyAuLi5yZXNwb25zZU1lc3NhZ2UgfV0sIGZhbHNlKTtcblxuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgYXdhaXQgcmVhZFJvdyhuZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvbWlzZSA9IGFwaSh7XG4gICAgICAgIG1lc3NhZ2VzOiBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCBhcyBNZXNzYWdlW10sXG4gICAgICAgIGRhdGE6IGNoYXRSZXF1ZXN0LmRhdGEsXG4gICAgICB9KSBhcyBQcm9taXNlPFJlYWN0UmVzcG9uc2VSb3c+O1xuICAgICAgYXdhaXQgcmVhZFJvdyhwcm9taXNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyBtZXNzYWdlcyBpZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgIG11dGF0ZShwcmV2aW91c01lc3NhZ2VzLCBmYWxzZSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlO1xuICB9XG5cbiAgcmV0dXJuIGF3YWl0IGNhbGxDaGF0QXBpKHtcbiAgICBhcGksXG4gICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkLFxuICAgIGJvZHk6IHtcbiAgICAgIGRhdGE6IGNoYXRSZXF1ZXN0LmRhdGEsXG4gICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuYm9keSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0Lm9wdGlvbnM/LmJvZHksXG4gICAgICAuLi4oY2hhdFJlcXVlc3QuZnVuY3Rpb25zICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICBmdW5jdGlvbnM6IGNoYXRSZXF1ZXN0LmZ1bmN0aW9ucyxcbiAgICAgIH0pLFxuICAgICAgLi4uKGNoYXRSZXF1ZXN0LmZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IGNoYXRSZXF1ZXN0LmZ1bmN0aW9uX2NhbGwsXG4gICAgICB9KSxcbiAgICAgIC4uLihjaGF0UmVxdWVzdC50b29scyAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgdG9vbHM6IGNoYXRSZXF1ZXN0LnRvb2xzLFxuICAgICAgfSksXG4gICAgICAuLi4oY2hhdFJlcXVlc3QudG9vbF9jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgIHRvb2xfY2hvaWNlOiBjaGF0UmVxdWVzdC50b29sX2Nob2ljZSxcbiAgICAgIH0pLFxuICAgIH0sXG4gICAgc3RyZWFtTW9kZSxcbiAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLFxuICAgICAgLi4uY2hhdFJlcXVlc3Qub3B0aW9ucz8uaGVhZGVycyxcbiAgICB9LFxuICAgIGFib3J0Q29udHJvbGxlcjogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQsXG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25VcGRhdGUobWVyZ2VkLCBkYXRhKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCAuLi5tZXJnZWRdLCBmYWxzZSk7XG4gICAgICBtdXRhdGVTdHJlYW1EYXRhKFsuLi4oZXhpc3RpbmdEYXRhIHx8IFtdKSwgLi4uKGRhdGEgfHwgW10pXSwgZmFsc2UpO1xuICAgIH0sXG4gICAgb25Ub29sQ2FsbCxcbiAgICBvbkZpbmlzaCxcbiAgICBnZW5lcmF0ZUlkLFxuICB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGF0KHtcbiAgYXBpID0gJy9hcGkvY2hhdCcsXG4gIGlkLFxuICBpbml0aWFsTWVzc2FnZXMsXG4gIGluaXRpYWxJbnB1dCA9ICcnLFxuICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICBvblRvb2xDYWxsLFxuICBleHBlcmltZW50YWxfbWF4QXV0b21hdGljUm91bmR0cmlwcyA9IDAsXG4gIG1heEF1dG9tYXRpY1JvdW5kdHJpcHMgPSBleHBlcmltZW50YWxfbWF4QXV0b21hdGljUm91bmR0cmlwcyxcbiAgbWF4VG9vbFJvdW5kdHJpcHMgPSBtYXhBdXRvbWF0aWNSb3VuZHRyaXBzLFxuICBzdHJlYW1Nb2RlLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIGdlbmVyYXRlSWQgPSBnZW5lcmF0ZUlkRnVuYyxcbn06IE9taXQ8VXNlQ2hhdE9wdGlvbnMsICdhcGknPiAmIHtcbiAgYXBpPzogc3RyaW5nIHwgU3RyZWFtaW5nUmVhY3RSZXNwb25zZUFjdGlvbjtcbiAga2V5Pzogc3RyaW5nO1xuICAvKipcbkBkZXByZWNhdGVkIFVzZSBgbWF4VG9vbFJvdW5kdHJpcHNgIGluc3RlYWQuXG4gICAqL1xuICBleHBlcmltZW50YWxfbWF4QXV0b21hdGljUm91bmR0cmlwcz86IG51bWJlcjtcblxuICAvKipcbkBkZXByZWNhdGVkIFVzZSBgbWF4VG9vbFJvdW5kdHJpcHNgIGluc3RlYWQuXG4gICAqL1xuICBtYXhBdXRvbWF0aWNSb3VuZHRyaXBzPzogbnVtYmVyO1xuXG4gIC8qKlxuTWF4aW1hbCBudW1iZXIgb2YgYXV0b21hdGljIHJvdW5kdHJpcHMgZm9yIHRvb2wgY2FsbHMuXG5cbkFuIGF1dG9tYXRpYyB0b29sIGNhbGwgcm91bmR0cmlwIGlzIGEgY2FsbCB0byB0aGUgc2VydmVyIHdpdGggdGhlIFxudG9vbCBjYWxsIHJlc3VsdHMgd2hlbiBhbGwgdG9vbCBjYWxscyBpbiB0aGUgbGFzdCBhc3Npc3RhbnQgXG5tZXNzYWdlIGhhdmUgcmVzdWx0cy5cblxuQSBtYXhpbXVtIG51bWJlciBpcyByZXF1aXJlZCB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzIGluIHRoZVxuY2FzZSBvZiBtaXNjb25maWd1cmVkIHRvb2xzLlxuXG5CeSBkZWZhdWx0LCBpdCdzIHNldCB0byAwLCB3aGljaCB3aWxsIGRpc2FibGUgdGhlIGZlYXR1cmUuXG4gICAqL1xuICBtYXhUb29sUm91bmR0cmlwcz86IG51bWJlcjtcbn0gPSB7fSk6IFVzZUNoYXRIZWxwZXJzICYge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBhZGRUb29sUmVzdWx0YCBpbnN0ZWFkLlxuICAgKi9cbiAgZXhwZXJpbWVudGFsX2FkZFRvb2xSZXN1bHQ6ICh7XG4gICAgdG9vbENhbGxJZCxcbiAgICByZXN1bHQsXG4gIH06IHtcbiAgICB0b29sQ2FsbElkOiBzdHJpbmc7XG4gICAgcmVzdWx0OiBhbnk7XG4gIH0pID0+IHZvaWQ7XG4gIGFkZFRvb2xSZXN1bHQ6ICh7XG4gICAgdG9vbENhbGxJZCxcbiAgICByZXN1bHQsXG4gIH06IHtcbiAgICB0b29sQ2FsbElkOiBzdHJpbmc7XG4gICAgcmVzdWx0OiBhbnk7XG4gIH0pID0+IHZvaWQ7XG59IHtcbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaWQgZm9yIHRoZSBjaGF0IGlmIG5vdCBwcm92aWRlZC5cbiAgY29uc3QgaG9va0lkID0gdXNlSWQoKTtcbiAgY29uc3QgaWRLZXkgPSBpZCA/PyBob29rSWQ7XG4gIGNvbnN0IGNoYXRLZXkgPSB0eXBlb2YgYXBpID09PSAnc3RyaW5nJyA/IFthcGksIGlkS2V5XSA6IGlkS2V5O1xuXG4gIC8vIFN0b3JlIGEgZW1wdHkgYXJyYXkgYXMgdGhlIGluaXRpYWwgbWVzc2FnZXNcbiAgLy8gKGluc3RlYWQgb2YgdXNpbmcgYSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZSB0aGF0IGdldHMgcmUtY3JlYXRlZCBlYWNoIHRpbWUpXG4gIC8vIHRvIGF2b2lkIHJlLXJlbmRlcnM6XG4gIGNvbnN0IFtpbml0aWFsTWVzc2FnZXNGYWxsYmFja10gPSB1c2VTdGF0ZShbXSk7XG5cbiAgLy8gU3RvcmUgdGhlIGNoYXQgc3RhdGUgaW4gU1dSLCB1c2luZyB0aGUgY2hhdElkIGFzIHRoZSBrZXkgdG8gc2hhcmUgc3RhdGVzLlxuICBjb25zdCB7IGRhdGE6IG1lc3NhZ2VzLCBtdXRhdGUgfSA9IHVzZVNXUjxNZXNzYWdlW10+KFxuICAgIFtjaGF0S2V5LCAnbWVzc2FnZXMnXSxcbiAgICBudWxsLFxuICAgIHsgZmFsbGJhY2tEYXRhOiBpbml0aWFsTWVzc2FnZXMgPz8gaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2sgfSxcbiAgKTtcblxuICAvLyBXZSBzdG9yZSBsb2FkaW5nIHN0YXRlIGluIGFub3RoZXIgaG9vayB0byBzeW5jIGxvYWRpbmcgc3RhdGVzIGFjcm9zcyBob29rIGludm9jYXRpb25zXG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSPGJvb2xlYW4+KFxuICAgIFtjaGF0S2V5LCAnbG9hZGluZyddLFxuICAgIG51bGwsXG4gICk7XG5cbiAgY29uc3QgeyBkYXRhOiBzdHJlYW1EYXRhLCBtdXRhdGU6IG11dGF0ZVN0cmVhbURhdGEgfSA9IHVzZVNXUjxcbiAgICBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZFxuICA+KFtjaGF0S2V5LCAnc3RyZWFtRGF0YSddLCBudWxsKTtcblxuICBjb25zdCB7IGRhdGE6IGVycm9yID0gdW5kZWZpbmVkLCBtdXRhdGU6IHNldEVycm9yIH0gPSB1c2VTV1I8XG4gICAgdW5kZWZpbmVkIHwgRXJyb3JcbiAgPihbY2hhdEtleSwgJ2Vycm9yJ10sIG51bGwpO1xuXG4gIC8vIEtlZXAgdGhlIGxhdGVzdCBtZXNzYWdlcyBpbiBhIHJlZi5cbiAgY29uc3QgbWVzc2FnZXNSZWYgPSB1c2VSZWY8TWVzc2FnZVtdPihtZXNzYWdlcyB8fCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzIHx8IFtdO1xuICB9LCBbbWVzc2FnZXNdKTtcblxuICAvLyBBYm9ydCBjb250cm9sbGVyIHRvIGNhbmNlbCB0aGUgY3VycmVudCBBUEkgY2FsbC5cbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmPEFib3J0Q29udHJvbGxlciB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IGV4dHJhTWV0YWRhdGFSZWYgPSB1c2VSZWYoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgfSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuXG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IodW5kZWZpbmVkKTtcblxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gYWJvcnRDb250cm9sbGVyO1xuXG4gICAgICAgIGF3YWl0IHByb2Nlc3NDaGF0U3RyZWFtKHtcbiAgICAgICAgICBnZXRTdHJlYW1lZFJlc3BvbnNlOiAoKSA9PlxuICAgICAgICAgICAgZ2V0U3RyZWFtZWRSZXNwb25zZShcbiAgICAgICAgICAgICAgYXBpLFxuICAgICAgICAgICAgICBjaGF0UmVxdWVzdCxcbiAgICAgICAgICAgICAgbXV0YXRlLFxuICAgICAgICAgICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgICAgICAgICBzdHJlYW1EYXRhISxcbiAgICAgICAgICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgICAgICAgICAgbWVzc2FnZXNSZWYsXG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZixcbiAgICAgICAgICAgICAgZ2VuZXJhdGVJZCxcbiAgICAgICAgICAgICAgc3RyZWFtTW9kZSxcbiAgICAgICAgICAgICAgb25GaW5pc2gsXG4gICAgICAgICAgICAgIG9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgIG9uVG9vbENhbGwsXG4gICAgICAgICAgICAgIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdDogY2hhdFJlcXVlc3RQYXJhbSA9PiB7XG4gICAgICAgICAgICBjaGF0UmVxdWVzdCA9IGNoYXRSZXF1ZXN0UGFyYW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXM6ICgpID0+IG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZ25vcmUgYWJvcnQgZXJyb3JzIGFzIHRoZXkgYXJlIGV4cGVjdGVkLlxuICAgICAgICBpZiAoKGVyciBhcyBhbnkpLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbkVycm9yICYmIGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0RXJyb3IoZXJyIGFzIEVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBhdXRvLXN1Ym1pdCB3aGVuIGFsbCB0b29sIGNhbGxzIGluIHRoZSBsYXN0IGFzc2lzdGFudCBtZXNzYWdlIGhhdmUgcmVzdWx0czpcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoXG4gICAgICAgIC8vIGVuc3VyZSB0aGVyZSBpcyBhIGxhc3QgbWVzc2FnZTpcbiAgICAgICAgbGFzdE1lc3NhZ2UgIT0gbnVsbCAmJlxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgZmVhdHVyZSBpcyBlbmFibGVkOlxuICAgICAgICBtYXhUb29sUm91bmR0cmlwcyA+IDAgJiZcbiAgICAgICAgLy8gY2hlY2sgdGhhdCByb3VuZHRyaXAgaXMgcG9zc2libGU6XG4gICAgICAgIGlzQXNzaXN0YW50TWVzc2FnZVdpdGhDb21wbGV0ZWRUb29sQ2FsbHMobGFzdE1lc3NhZ2UpICYmXG4gICAgICAgIC8vIGxpbWl0IHRoZSBudW1iZXIgb2YgYXV0b21hdGljIHJvdW5kdHJpcHM6XG4gICAgICAgIGNvdW50VHJhaWxpbmdBc3Npc3RhbnRNZXNzYWdlcyhtZXNzYWdlcykgPD0gbWF4VG9vbFJvdW5kdHJpcHNcbiAgICAgICkge1xuICAgICAgICBhd2FpdCB0cmlnZ2VyUmVxdWVzdCh7IG1lc3NhZ2VzIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgc3RyZWFtRGF0YSxcbiAgICAgIHN0cmVhbU1vZGUsXG4gICAgICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICAgICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gICAgICBvblRvb2xDYWxsLFxuICAgICAgbWF4VG9vbFJvdW5kdHJpcHMsXG4gICAgICBtZXNzYWdlc1JlZixcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZixcbiAgICAgIGdlbmVyYXRlSWQsXG4gICAgXSxcbiAgKTtcblxuICBjb25zdCBhcHBlbmQgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoXG4gICAgICBtZXNzYWdlOiBNZXNzYWdlIHwgQ3JlYXRlTWVzc2FnZSxcbiAgICAgIHtcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZnVuY3Rpb25zLFxuICAgICAgICBmdW5jdGlvbl9jYWxsLFxuICAgICAgICB0b29scyxcbiAgICAgICAgdG9vbF9jaG9pY2UsXG4gICAgICAgIGRhdGEsXG4gICAgICB9OiBDaGF0UmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICApID0+IHtcbiAgICAgIGlmICghbWVzc2FnZS5pZCkge1xuICAgICAgICBtZXNzYWdlLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LmNvbmNhdChtZXNzYWdlIGFzIE1lc3NhZ2UpLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBkYXRhLFxuICAgICAgICAuLi4oZnVuY3Rpb25zICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbnMgfSksXG4gICAgICAgIC4uLihmdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbl9jYWxsIH0pLFxuICAgICAgICAuLi4odG9vbHMgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xzIH0pLFxuICAgICAgICAuLi4odG9vbF9jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xfY2hvaWNlIH0pLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdCwgZ2VuZXJhdGVJZF0sXG4gICk7XG5cbiAgY29uc3QgcmVsb2FkID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBmdW5jdGlvbnMsXG4gICAgICBmdW5jdGlvbl9jYWxsLFxuICAgICAgdG9vbHMsXG4gICAgICB0b29sX2Nob2ljZSxcbiAgICB9OiBDaGF0UmVxdWVzdE9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2VzUmVmLmN1cnJlbnQubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gUmVtb3ZlIGxhc3QgYXNzaXN0YW50IG1lc3NhZ2UgYW5kIHJldHJ5IGxhc3QgdXNlciBtZXNzYWdlLlxuICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1JlZi5jdXJyZW50W21lc3NhZ2VzUmVmLmN1cnJlbnQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE1lc3NhZ2Uucm9sZSA9PT0gJ2Fzc2lzdGFudCcpIHtcbiAgICAgICAgY29uc3QgY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0ID0ge1xuICAgICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LnNsaWNlKDAsIC0xKSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIC4uLihmdW5jdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9ucyB9KSxcbiAgICAgICAgICAuLi4oZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25fY2FsbCB9KSxcbiAgICAgICAgICAuLi4odG9vbHMgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xzIH0pLFxuICAgICAgICAgIC4uLih0b29sX2Nob2ljZSAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbF9jaG9pY2UgfSksXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgLi4uKGZ1bmN0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25zIH0pLFxuICAgICAgICAuLi4oZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25fY2FsbCB9KSxcbiAgICAgICAgLi4uKHRvb2xzICE9PSB1bmRlZmluZWQgJiYgeyB0b29scyB9KSxcbiAgICAgICAgLi4uKHRvb2xfY2hvaWNlICE9PSB1bmRlZmluZWQgJiYgeyB0b29sX2Nob2ljZSB9KSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdLFxuICApO1xuXG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5hYm9ydCgpO1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldE1lc3NhZ2VzID0gdXNlQ2FsbGJhY2soXG4gICAgKG1lc3NhZ2VzOiBNZXNzYWdlW10pID0+IHtcbiAgICAgIG11dGF0ZShtZXNzYWdlcywgZmFsc2UpO1xuICAgICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzO1xuICAgIH0sXG4gICAgW211dGF0ZV0sXG4gICk7XG5cbiAgLy8gSW5wdXQgc3RhdGUgYW5kIGhhbmRsZXJzLlxuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKGluaXRpYWxJbnB1dCk7XG5cbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKFxuICAgICAgZTogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4sXG4gICAgICBvcHRpb25zOiBDaGF0UmVxdWVzdE9wdGlvbnMgPSB7fSxcbiAgICAgIG1ldGFkYXRhPzogT2JqZWN0LFxuICAgICkgPT4ge1xuICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICghaW5wdXQpIHJldHVybjtcblxuICAgICAgYXBwZW5kKFxuICAgICAgICB7XG4gICAgICAgICAgY29udGVudDogaW5wdXQsXG4gICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICk7XG4gICAgICBzZXRJbnB1dCgnJyk7XG4gICAgfSxcbiAgICBbaW5wdXQsIGFwcGVuZF0sXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoZTogYW55KSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuXG4gIGNvbnN0IGFkZFRvb2xSZXN1bHQgPSAoe1xuICAgIHRvb2xDYWxsSWQsXG4gICAgcmVzdWx0LFxuICB9OiB7XG4gICAgdG9vbENhbGxJZDogc3RyaW5nO1xuICAgIHJlc3VsdDogYW55O1xuICB9KSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZE1lc3NhZ2VzID0gbWVzc2FnZXNSZWYuY3VycmVudC5tYXAoKG1lc3NhZ2UsIGluZGV4LCBhcnIpID0+XG4gICAgICAvLyB1cGRhdGUgdGhlIHRvb2wgY2FsbHMgaW4gdGhlIGxhc3QgYXNzaXN0YW50IG1lc3NhZ2U6XG4gICAgICBpbmRleCA9PT0gYXJyLmxlbmd0aCAtIDEgJiZcbiAgICAgIG1lc3NhZ2Uucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiZcbiAgICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9uczogbWVzc2FnZS50b29sSW52b2NhdGlvbnMubWFwKHRvb2xJbnZvY2F0aW9uID0+XG4gICAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9uLnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgICA/IHsgLi4udG9vbEludm9jYXRpb24sIHJlc3VsdCB9XG4gICAgICAgICAgICAgICAgOiB0b29sSW52b2NhdGlvbixcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfVxuICAgICAgICA6IG1lc3NhZ2UsXG4gICAgKTtcblxuICAgIG11dGF0ZSh1cGRhdGVkTWVzc2FnZXMsIGZhbHNlKTtcblxuICAgIC8vIGF1dG8tc3VibWl0IHdoZW4gYWxsIHRvb2wgY2FsbHMgaW4gdGhlIGxhc3QgYXNzaXN0YW50IG1lc3NhZ2UgaGF2ZSByZXN1bHRzOlxuICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gdXBkYXRlZE1lc3NhZ2VzW3VwZGF0ZWRNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxscyhsYXN0TWVzc2FnZSkpIHtcbiAgICAgIHRyaWdnZXJSZXF1ZXN0KHsgbWVzc2FnZXM6IHVwZGF0ZWRNZXNzYWdlcyB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlczogbWVzc2FnZXMgfHwgW10sXG4gICAgZXJyb3IsXG4gICAgYXBwZW5kLFxuICAgIHJlbG9hZCxcbiAgICBzdG9wLFxuICAgIHNldE1lc3NhZ2VzLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIGhhbmRsZVN1Ym1pdCxcbiAgICBpc0xvYWRpbmcsXG4gICAgZGF0YTogc3RyZWFtRGF0YSxcbiAgICBhZGRUb29sUmVzdWx0LFxuICAgIGV4cGVyaW1lbnRhbF9hZGRUb29sUmVzdWx0OiBhZGRUb29sUmVzdWx0LFxuICB9O1xufVxuXG4vKipcbkNoZWNrIGlmIHRoZSBtZXNzYWdlIGlzIGFuIGFzc2lzdGFudCBtZXNzYWdlIHdpdGggY29tcGxldGVkIHRvb2wgY2FsbHMuIFxuVGhlIG1lc3NhZ2UgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSB0b29sIGludm9jYXRpb24gYW5kIGFsbCB0b29sIGludm9jYXRpb25zXG5tdXN0IGhhdmUgYSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzQXNzaXN0YW50TWVzc2FnZVdpdGhDb21wbGV0ZWRUb29sQ2FsbHMobWVzc2FnZTogTWVzc2FnZSkge1xuICByZXR1cm4gKFxuICAgIG1lc3NhZ2Uucm9sZSA9PT0gJ2Fzc2lzdGFudCcgJiZcbiAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucyAmJlxuICAgIG1lc3NhZ2UudG9vbEludm9jYXRpb25zLmxlbmd0aCA+IDAgJiZcbiAgICBtZXNzYWdlLnRvb2xJbnZvY2F0aW9ucy5ldmVyeSh0b29sSW52b2NhdGlvbiA9PiAncmVzdWx0JyBpbiB0b29sSW52b2NhdGlvbilcbiAgKTtcbn1cblxuLyoqXG5SZXR1cm5zIHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgYXNzaXN0YW50IG1lc3NhZ2VzIGluIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY291bnRUcmFpbGluZ0Fzc2lzdGFudE1lc3NhZ2VzKG1lc3NhZ2VzOiBNZXNzYWdlW10pIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IG1lc3NhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKG1lc3NhZ2VzW2ldLnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICBjb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuIiwiaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tICduYW5vaWQvbm9uLXNlY3VyZSc7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgNy1jaGFyYWN0ZXIgcmFuZG9tIHN0cmluZyB0byB1c2UgZm9yIElEcy4gTm90IHNlY3VyZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlSWQgPSBjdXN0b21BbHBoYWJldChcbiAgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcbiAgNyxcbik7XG4iLCJpbXBvcnQgeyBUb29sQ2FsbCBhcyBDb3JlVG9vbENhbGwgfSBmcm9tICcuLi9jb3JlL2dlbmVyYXRlLXRleHQvdG9vbC1jYWxsJztcbmltcG9ydCB7IFRvb2xSZXN1bHQgYXMgQ29yZVRvb2xSZXN1bHQgfSBmcm9tICcuLi9jb3JlL2dlbmVyYXRlLXRleHQvdG9vbC1yZXN1bHQnO1xuaW1wb3J0IHtcbiAgQXNzaXN0YW50TWVzc2FnZSxcbiAgRGF0YU1lc3NhZ2UsXG4gIEZ1bmN0aW9uQ2FsbCxcbiAgSlNPTlZhbHVlLFxuICBUb29sQ2FsbCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTdHJlYW1TdHJpbmcgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBTdHJlYW1QYXJ0PENPREUgZXh0ZW5kcyBzdHJpbmcsIE5BTUUgZXh0ZW5kcyBzdHJpbmcsIFRZUEU+IHtcbiAgY29kZTogQ09ERTtcbiAgbmFtZTogTkFNRTtcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7IHR5cGU6IE5BTUU7IHZhbHVlOiBUWVBFIH07XG59XG5cbmNvbnN0IHRleHRTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCcwJywgJ3RleHQnLCBzdHJpbmc+ID0ge1xuICBjb2RlOiAnMCcsXG4gIG5hbWU6ICd0ZXh0JyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAndGV4dCcsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnMScsXG4gICdmdW5jdGlvbl9jYWxsJyxcbiAgeyBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGwgfVxuPiA9IHtcbiAgY29kZTogJzEnLFxuICBuYW1lOiAnZnVuY3Rpb25fY2FsbCcsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ2Z1bmN0aW9uX2NhbGwnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09ICdvYmplY3QnIHx8XG4gICAgICB2YWx1ZS5mdW5jdGlvbl9jYWxsID09IG51bGwgfHxcbiAgICAgICEoJ25hbWUnIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8XG4gICAgICAhKCdhcmd1bWVudHMnIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdmdW5jdGlvbl9jYWxsJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIHsgZnVuY3Rpb25fY2FsbDogRnVuY3Rpb25DYWxsIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGRhdGFTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCcyJywgJ2RhdGEnLCBBcnJheTxKU09OVmFsdWU+PiA9IHtcbiAgY29kZTogJzInLFxuICBuYW1lOiAnZGF0YScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdkYXRhJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGVycm9yU3RyZWFtUGFydDogU3RyZWFtUGFydDwnMycsICdlcnJvcicsIHN0cmluZz4gPSB7XG4gIGNvZGU6ICczJyxcbiAgbmFtZTogJ2Vycm9yJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJlcnJvclwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ2Vycm9yJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNCcsXG4gICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gIEFzc2lzdGFudE1lc3NhZ2Vcbj4gPSB7XG4gIGNvZGU6ICc0JyxcbiAgbmFtZTogJ2Fzc2lzdGFudF9tZXNzYWdlJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgnaWQnIGluIHZhbHVlKSB8fFxuICAgICAgISgncm9sZScgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdjb250ZW50JyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5pZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5yb2xlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdmFsdWUucm9sZSAhPT0gJ2Fzc2lzdGFudCcgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8XG4gICAgICAhdmFsdWUuY29udGVudC5ldmVyeShcbiAgICAgICAgaXRlbSA9PlxuICAgICAgICAgIGl0ZW0gIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICd0eXBlJyBpbiBpdGVtICYmXG4gICAgICAgICAgaXRlbS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgICAndGV4dCcgaW4gaXRlbSAmJlxuICAgICAgICAgIGl0ZW0udGV4dCAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIGl0ZW0udGV4dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAndmFsdWUnIGluIGl0ZW0udGV4dCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtLnRleHQudmFsdWUgPT09ICdzdHJpbmcnLFxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgQXNzaXN0YW50TWVzc2FnZSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNScsXG4gICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJyxcbiAge1xuICAgIHRocmVhZElkOiBzdHJpbmc7XG4gICAgbWVzc2FnZUlkOiBzdHJpbmc7XG4gIH1cbj4gPSB7XG4gIGNvZGU6ICc1JyxcbiAgbmFtZTogJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCd0aHJlYWRJZCcgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdtZXNzYWdlSWQnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdGhyZWFkSWQ6IHZhbHVlLnRocmVhZElkLFxuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGRhdGFNZXNzYWdlU3RyZWFtUGFydDogU3RyZWFtUGFydDwnNicsICdkYXRhX21lc3NhZ2UnLCBEYXRhTWVzc2FnZT4gPSB7XG4gIGNvZGU6ICc2JyxcbiAgbmFtZTogJ2RhdGFfbWVzc2FnZScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3JvbGUnIGluIHZhbHVlKSB8fFxuICAgICAgISgnZGF0YScgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUucm9sZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHZhbHVlLnJvbGUgIT09ICdkYXRhJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJkYXRhX21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInJvbGVcIiBhbmQgXCJkYXRhXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdkYXRhX21lc3NhZ2UnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIERhdGFNZXNzYWdlLFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCB0b29sQ2FsbHNTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNycsXG4gICd0b29sX2NhbGxzJyxcbiAgeyB0b29sX2NhbGxzOiBUb29sQ2FsbFtdIH1cbj4gPSB7XG4gIGNvZGU6ICc3JyxcbiAgbmFtZTogJ3Rvb2xfY2FsbHMnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCd0b29sX2NhbGxzJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS50b29sX2NhbGxzICE9PSAnb2JqZWN0JyB8fFxuICAgICAgdmFsdWUudG9vbF9jYWxscyA9PSBudWxsIHx8XG4gICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZS50b29sX2NhbGxzKSB8fFxuICAgICAgdmFsdWUudG9vbF9jYWxscy5zb21lKFxuICAgICAgICB0YyA9PlxuICAgICAgICAgIHRjID09IG51bGwgfHxcbiAgICAgICAgICB0eXBlb2YgdGMgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgISgnaWQnIGluIHRjKSB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5pZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAhKCd0eXBlJyBpbiB0YykgfHxcbiAgICAgICAgICB0eXBlb2YgdGMudHlwZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAhKCdmdW5jdGlvbicgaW4gdGMpIHx8XG4gICAgICAgICAgdGMuZnVuY3Rpb24gPT0gbnVsbCB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5mdW5jdGlvbiAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAhKCdhcmd1bWVudHMnIGluIHRjLmZ1bmN0aW9uKSB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5mdW5jdGlvbi5uYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgIHR5cGVvZiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMgIT09ICdzdHJpbmcnLFxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxzXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgVG9vbENhbGxQYXlsb2FkLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAndG9vbF9jYWxscycsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgdW5rbm93biBhcyB7IHRvb2xfY2FsbHM6IFRvb2xDYWxsW10gfSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydDogU3RyZWFtUGFydDxcbiAgJzgnLFxuICAnbWVzc2FnZV9hbm5vdGF0aW9ucycsXG4gIEFycmF5PEpTT05WYWx1ZT5cbj4gPSB7XG4gIGNvZGU6ICc4JyxcbiAgbmFtZTogJ21lc3NhZ2VfYW5ub3RhdGlvbnMnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZV9hbm5vdGF0aW9uc1wiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiAnbWVzc2FnZV9hbm5vdGF0aW9ucycsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCB0b29sQ2FsbFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc5JyxcbiAgJ3Rvb2xfY2FsbCcsXG4gIENvcmVUb29sQ2FsbDxzdHJpbmcsIGFueT5cbj4gPSB7XG4gIGNvZGU6ICc5JyxcbiAgbmFtZTogJ3Rvb2xfY2FsbCcsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3Rvb2xDYWxsSWQnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICAhKCd0b29sTmFtZScgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUudG9vbE5hbWUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAhKCdhcmdzJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5hcmdzICE9PSAnb2JqZWN0J1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiwgXCJ0b29sTmFtZVwiLCBhbmQgXCJhcmdzXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0b29sX2NhbGwnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIHVua25vd24gYXMgQ29yZVRvb2xDYWxsPHN0cmluZywgYW55PixcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgdG9vbFJlc3VsdFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICdhJyxcbiAgJ3Rvb2xfcmVzdWx0JyxcbiAgQ29yZVRvb2xSZXN1bHQ8c3RyaW5nLCBhbnksIGFueT5cbj4gPSB7XG4gIGNvZGU6ICdhJyxcbiAgbmFtZTogJ3Rvb2xfcmVzdWx0JyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgndG9vbENhbGxJZCcgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUudG9vbENhbGxJZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICEoJ3Rvb2xOYW1lJyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS50b29sTmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICEoJ2FyZ3MnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmFyZ3MgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCdyZXN1bHQnIGluIHZhbHVlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX3Jlc3VsdFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidG9vbENhbGxJZFwiLCBcInRvb2xOYW1lXCIsIFwiYXJnc1wiLCBhbmQgXCJyZXN1bHRcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3Rvb2xfcmVzdWx0JyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIENvcmVUb29sUmVzdWx0PHN0cmluZywgYW55LCBhbnk+LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBzdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgdG9vbENhbGxzU3RyZWFtUGFydCxcbiAgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuICB0b29sUmVzdWx0U3RyZWFtUGFydCxcbl0gYXMgY29uc3Q7XG5cbi8vIHVuaW9uIHR5cGUgb2YgYWxsIHN0cmVhbSBwYXJ0c1xudHlwZSBTdHJlYW1QYXJ0cyA9XG4gIHwgdHlwZW9mIHRleHRTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZGF0YVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZXJyb3JTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydFxuICB8IHR5cGVvZiBkYXRhTWVzc2FnZVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgdG9vbENhbGxzU3RyZWFtUGFydFxuICB8IHR5cGVvZiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIHRvb2xDYWxsU3RyZWFtUGFydFxuICB8IHR5cGVvZiB0b29sUmVzdWx0U3RyZWFtUGFydDtcblxuLyoqXG4gKiBNYXBzIHRoZSB0eXBlIG9mIGEgc3RyZWFtIHBhcnQgdG8gaXRzIHZhbHVlIHR5cGUuXG4gKi9cbnR5cGUgU3RyZWFtUGFydFZhbHVlVHlwZSA9IHtcbiAgW1AgaW4gU3RyZWFtUGFydHMgYXMgUFsnbmFtZSddXTogUmV0dXJuVHlwZTxQWydwYXJzZSddPlsndmFsdWUnXTtcbn07XG5cbmV4cG9ydCB0eXBlIFN0cmVhbVBhcnRUeXBlID1cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiB0ZXh0U3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGRhdGFTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGVycm9yU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIHRvb2xDYWxsc1N0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiB0b29sQ2FsbFN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgdG9vbFJlc3VsdFN0cmVhbVBhcnQucGFyc2U+O1xuXG5leHBvcnQgY29uc3Qgc3RyZWFtUGFydHNCeUNvZGUgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5jb2RlXTogdGV4dFN0cmVhbVBhcnQsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBbZGF0YVN0cmVhbVBhcnQuY29kZV06IGRhdGFTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxzU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxzU3RyZWFtUGFydCxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQuY29kZV06IHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgW3Rvb2xSZXN1bHRTdHJlYW1QYXJ0LmNvZGVdOiB0b29sUmVzdWx0U3RyZWFtUGFydCxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogVGhlIG1hcCBvZiBwcmVmaXhlcyBmb3IgZGF0YSBpbiB0aGUgc3RyZWFtXG4gKlxuICogLSAwOiBUZXh0IGZyb20gdGhlIExMTSByZXNwb25zZVxuICogLSAxOiAoT3BlbkFJKSBmdW5jdGlvbl9jYWxsIHJlc3BvbnNlc1xuICogLSAyOiBjdXN0b20gSlNPTiBhZGRlZCBieSB0aGUgdXNlciB1c2luZyBgRGF0YWBcbiAqIC0gNjogKE9wZW5BSSkgdG9vbF9jYWxsIHJlc3BvbnNlc1xuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBcbiAqIDA6VmVyY2VsXG4gKiAwOidzXG4gKiAwOiBBSVxuICogMDogQUlcbiAqIDA6IFNES1xuICogMDogaXMgZ3JlYXRcbiAqIDA6IVxuICogMjogeyBcInNvbWVKc29uXCI6IFwidmFsdWVcIiB9XG4gKiAxOiB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCJnZXRfY3VycmVudF93ZWF0aGVyXCIsIFwiYXJndW1lbnRzXCI6IFwie1xcXFxuXFxcXFwibG9jYXRpb25cXFxcXCI6IFxcXFxcIkNoYXJsb3R0ZXN2aWxsZSwgVmlyZ2luaWFcXFxcXCIsXFxcXG5cXFxcXCJmb3JtYXRcXFxcXCI6IFxcXFxcImNlbHNpdXNcXFxcXCJcXFxcbn1cIn19XG4gKiA2OiB7XCJ0b29sX2NhbGxcIjoge1wiaWRcIjogXCJ0b29sXzBcIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiZ2V0X2N1cnJlbnRfd2VhdGhlclwiLCBcImFyZ3VtZW50c1wiOiBcIntcXFxcblxcXFxcImxvY2F0aW9uXFxcXFwiOiBcXFxcXCJDaGFybG90dGVzdmlsbGUsIFZpcmdpbmlhXFxcXFwiLFxcXFxuXFxcXFwiZm9ybWF0XFxcXFwiOiBcXFxcXCJjZWxzaXVzXFxcXFwiXFxcXG59XCJ9fX1cbiAqYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsc1N0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsc1N0cmVhbVBhcnQuY29kZSxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQubmFtZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sUmVzdWx0U3RyZWFtUGFydC5uYW1lXTogdG9vbFJlc3VsdFN0cmVhbVBhcnQuY29kZSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCB2YWxpZENvZGVzID0gc3RyZWFtUGFydHMubWFwKHBhcnQgPT4gcGFydC5jb2RlKTtcblxuLyoqXG5QYXJzZXMgYSBzdHJlYW0gcGFydCBmcm9tIGEgc3RyaW5nLlxuXG5AcGFyYW0gbGluZSBUaGUgc3RyaW5nIHRvIHBhcnNlLlxuQHJldHVybnMgVGhlIHBhcnNlZCBzdHJlYW0gcGFydC5cbkB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIHN0cmluZyBjYW5ub3QgYmUgcGFyc2VkLlxuICovXG5leHBvcnQgY29uc3QgcGFyc2VTdHJlYW1QYXJ0ID0gKGxpbmU6IHN0cmluZyk6IFN0cmVhbVBhcnRUeXBlID0+IHtcbiAgY29uc3QgZmlyc3RTZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuXG4gIGlmIChmaXJzdFNlcGFyYXRvckluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIE5vIHNlcGFyYXRvciBmb3VuZC4nKTtcbiAgfVxuXG4gIGNvbnN0IHByZWZpeCA9IGxpbmUuc2xpY2UoMCwgZmlyc3RTZXBhcmF0b3JJbmRleCk7XG5cbiAgaWYgKCF2YWxpZENvZGVzLmluY2x1ZGVzKHByZWZpeCBhcyBrZXlvZiB0eXBlb2Ygc3RyZWFtUGFydHNCeUNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gSW52YWxpZCBjb2RlICR7cHJlZml4fS5gKTtcbiAgfVxuXG4gIGNvbnN0IGNvZGUgPSBwcmVmaXggYXMga2V5b2YgdHlwZW9mIHN0cmVhbVBhcnRzQnlDb2RlO1xuXG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWU6IEpTT05WYWx1ZSA9IEpTT04ucGFyc2UodGV4dFZhbHVlKTtcblxuICByZXR1cm4gc3RyZWFtUGFydHNCeUNvZGVbY29kZV0ucGFyc2UoanNvblZhbHVlKTtcbn07XG5cbi8qKlxuUHJlcGVuZHMgYSBzdHJpbmcgd2l0aCBhIHByZWZpeCBmcm9tIHRoZSBgU3RyZWFtQ2h1bmtQcmVmaXhlc2AsIEpTT04taWZpZXMgaXQsXG5hbmQgYXBwZW5kcyBhIG5ldyBsaW5lLlxuXG5JdCBlbnN1cmVzIHR5cGUtc2FmZXR5IGZvciB0aGUgcGFydCB0eXBlIGFuZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFN0cmVhbVBhcnQ8VCBleHRlbmRzIGtleW9mIFN0cmVhbVBhcnRWYWx1ZVR5cGU+KFxuICB0eXBlOiBULFxuICB2YWx1ZTogU3RyZWFtUGFydFZhbHVlVHlwZVtUXSxcbik6IFN0cmVhbVN0cmluZyB7XG4gIGNvbnN0IHN0cmVhbVBhcnQgPSBzdHJlYW1QYXJ0cy5maW5kKHBhcnQgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcblxuICBpZiAoIXN0cmVhbVBhcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RyZWFtIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG5cbiAgcmV0dXJuIGAke3N0cmVhbVBhcnQuY29kZX06JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XFxuYDtcbn1cbiIsImltcG9ydCB7IFN0cmVhbVBhcnRUeXBlLCBwYXJzZVN0cmVhbVBhcnQgfSBmcm9tICcuL3N0cmVhbS1wYXJ0cyc7XG5cbmNvbnN0IE5FV0xJTkUgPSAnXFxuJy5jaGFyQ29kZUF0KDApO1xuXG4vLyBjb25jYXRlbmF0ZXMgYWxsIHRoZSBjaHVua3MgaW50byBhIHNpbmdsZSBVaW50OEFycmF5XG5mdW5jdGlvbiBjb25jYXRDaHVua3MoY2h1bmtzOiBVaW50OEFycmF5W10sIHRvdGFsTGVuZ3RoOiBudW1iZXIpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGNvbmNhdGVuYXRlZENodW5rcy5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICBjaHVua3MubGVuZ3RoID0gMDtcblxuICByZXR1cm4gY29uY2F0ZW5hdGVkQ2h1bmtzO1xufVxuXG4vKipcbkNvbnZlcnRzIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIGludG8gYW4gYXN5bmMgZ2VuZXJhdG9yIHRoYXQgeWllbGRzXG5TdHJlYW1QYXJ0IG9iamVjdHMuXG5cbkBwYXJhbSByZWFkZXIgXG4gICAgICAgUmVhZGVyIGZvciB0aGUgc3RyZWFtIHRvIHJlYWQgZnJvbS5cbkBwYXJhbSBpc0Fib3J0ZWRcbiAgICAgICBPcHRpb25hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLlxuICAgICAgIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIHRoZSBnZW5lcmF0b3Igd2lsbCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAgICAgICBJZiB0aGUgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCB0aGUgZ2VuZXJhdG9yIHdpbGwgbm90IHN0b3AgcmVhZGluZyB0aGUgc3RyZWFtLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIHJlYWREYXRhU3RyZWFtKFxuICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5PixcbiAge1xuICAgIGlzQWJvcnRlZCxcbiAgfToge1xuICAgIGlzQWJvcnRlZD86ICgpID0+IGJvb2xlYW47XG4gIH0gPSB7fSxcbik6IEFzeW5jR2VuZXJhdG9yPFN0cmVhbVBhcnRUeXBlPiB7XG4gIC8vIGltcGxlbWVudGF0aW9uIG5vdGU6IHRoaXMgc2xpZ2h0bHkgbW9yZSBjb21wbGV4IGFsZ29yaXRobSBpcyByZXF1aXJlZFxuICAvLyB0byBwYXNzIHRoZSB0ZXN0cyBpbiB0aGUgZWRnZSBlbnZpcm9ubWVudC5cblxuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGNvbnN0IGNodW5rczogVWludDhBcnJheVtdID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgICB0b3RhbExlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09IE5FV0xJTkUpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIG5vdCBhIG5ld2xpbmUsIHdlIGhhdmUgbm90IHJlYWQgdGhlIHdob2xlIEpTT04gdmFsdWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrOyAvLyB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc3RyZWFtXG4gICAgfVxuXG4gICAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpO1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcblxuICAgIGNvbnN0IHN0cmVhbVBhcnRzID0gZGVjb2RlclxuICAgICAgLmRlY29kZShjb25jYXRlbmF0ZWRDaHVua3MsIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAuZmlsdGVyKGxpbmUgPT4gbGluZSAhPT0gJycpIC8vIHNwbGl0dGluZyBsZWF2ZXMgYW4gZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmRcbiAgICAgIC5tYXAocGFyc2VTdHJlYW1QYXJ0KTtcblxuICAgIGZvciAoY29uc3Qgc3RyZWFtUGFydCBvZiBzdHJlYW1QYXJ0cykge1xuICAgICAgeWllbGQgc3RyZWFtUGFydDtcbiAgICB9XG5cbiAgICAvLyBUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAgICBpZiAoaXNBYm9ydGVkPy4oKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jdGlvbiB9IGZyb20gJy4vZ2VuZXJhdGUtaWQnO1xuaW1wb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuL3JlYWQtZGF0YS1zdHJlYW0nO1xuaW1wb3J0IHR5cGUge1xuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgTWVzc2FnZSxcbiAgVG9vbENhbGwsXG4gIFVzZUNoYXRPcHRpb25zLFxufSBmcm9tICcuL3R5cGVzJztcblxudHlwZSBQcmVmaXhNYXAgPSB7XG4gIHRleHQ/OiBNZXNzYWdlO1xuICAvLyBAZGVwcmVjYXRlZFxuICBmdW5jdGlvbl9jYWxsPzogTWVzc2FnZSAmIHtcbiAgICByb2xlOiAnYXNzaXN0YW50JztcbiAgICBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGw7XG4gIH07XG4gIC8vIEBkZXByZWNhdGVkXG4gIHRvb2xfY2FsbHM/OiBNZXNzYWdlICYge1xuICAgIHJvbGU6ICdhc3Npc3RhbnQnO1xuICAgIHRvb2xfY2FsbHM6IFRvb2xDYWxsW107XG4gIH07XG4gIGRhdGE6IEpTT05WYWx1ZVtdO1xufTtcblxuZnVuY3Rpb24gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2U8VCBleHRlbmRzIE1lc3NhZ2UgfCBudWxsIHwgdW5kZWZpbmVkPihcbiAgbWVzc2FnZTogVCxcbiAgYW5ub3RhdGlvbnM6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkLFxuKTogVCB7XG4gIGlmICghbWVzc2FnZSB8fCAhYW5ub3RhdGlvbnMgfHwgIWFubm90YXRpb25zLmxlbmd0aCkgcmV0dXJuIG1lc3NhZ2U7XG4gIHJldHVybiB7IC4uLm1lc3NhZ2UsIGFubm90YXRpb25zOiBbLi4uYW5ub3RhdGlvbnNdIH0gYXMgVDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlQ29tcGxleFJlc3BvbnNlKHtcbiAgcmVhZGVyLFxuICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gIHVwZGF0ZSxcbiAgb25Ub29sQ2FsbCxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQgPSBnZW5lcmF0ZUlkRnVuY3Rpb24sXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gbmV3IERhdGUoKSxcbn06IHtcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT47XG4gIGFib3J0Q29udHJvbGxlclJlZj86IHtcbiAgICBjdXJyZW50OiBBYm9ydENvbnRyb2xsZXIgfCBudWxsO1xuICB9O1xuICB1cGRhdGU6IChtZXJnZWQ6IE1lc3NhZ2VbXSwgZGF0YTogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQpID0+IHZvaWQ7XG4gIG9uVG9vbENhbGw/OiBVc2VDaGF0T3B0aW9uc1snb25Ub29sQ2FsbCddO1xuICBvbkZpbmlzaD86IChwcmVmaXhNYXA6IFByZWZpeE1hcCkgPT4gdm9pZDtcbiAgZ2VuZXJhdGVJZD86ICgpID0+IHN0cmluZztcbiAgZ2V0Q3VycmVudERhdGU/OiAoKSA9PiBEYXRlO1xufSkge1xuICBjb25zdCBjcmVhdGVkQXQgPSBnZXRDdXJyZW50RGF0ZSgpO1xuICBjb25zdCBwcmVmaXhNYXA6IFByZWZpeE1hcCA9IHtcbiAgICBkYXRhOiBbXSxcbiAgfTtcblxuICAvLyBrZWVwIGxpc3Qgb2YgY3VycmVudCBtZXNzYWdlIGFubm90YXRpb25zIGZvciBtZXNzYWdlXG4gIGxldCBtZXNzYWdlX2Fubm90YXRpb25zOiBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAvLyB3ZSBjcmVhdGUgYSBtYXAgb2YgZWFjaCBwcmVmaXgsIGFuZCBmb3IgZWFjaCBwcmVmaXhlZCBtZXNzYWdlIHdlIHB1c2ggdG8gdGhlIG1hcFxuICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShyZWFkZXIsIHtcbiAgICBpc0Fib3J0ZWQ6ICgpID0+IGFib3J0Q29udHJvbGxlclJlZj8uY3VycmVudCA9PT0gbnVsbCxcbiAgfSkpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBpZiAocHJlZml4TWFwWyd0ZXh0J10pIHtcbiAgICAgICAgcHJlZml4TWFwWyd0ZXh0J10gPSB7XG4gICAgICAgICAgLi4ucHJlZml4TWFwWyd0ZXh0J10sXG4gICAgICAgICAgY29udGVudDogKHByZWZpeE1hcFsndGV4dCddLmNvbnRlbnQgfHwgJycpICsgdmFsdWUsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXhNYXBbJ3RleHQnXSA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLFxuICAgICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUb29sIGludm9jYXRpb25zIGFyZSBwYXJ0IG9mIGFuIGFzc2lzdGFudCBtZXNzYWdlXG4gICAgaWYgKHR5cGUgPT09ICd0b29sX2NhbGwnKSB7XG4gICAgICAvLyBjcmVhdGUgbWVzc2FnZSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAocHJlZml4TWFwLnRleHQgPT0gbnVsbCkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dCA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMucHVzaCh2YWx1ZSk7XG5cbiAgICAgIC8vIGludm9rZSB0aGUgb25Ub29sQ2FsbCBjYWxsYmFjayBpZiBpdCBleGlzdHMuIFRoaXMgaXMgYmxvY2tpbmcuXG4gICAgICAvLyBJbiB0aGUgZnV0dXJlIHdlIHNob3VsZCBtYWtlIHRoaXMgbm9uLWJsb2NraW5nLCB3aGljaFxuICAgICAgLy8gcmVxdWlyZXMgYWRkaXRpb25hbCBzdGF0ZSBtYW5hZ2VtZW50IGZvciBlcnJvciBoYW5kbGluZyBldGMuXG4gICAgICBpZiAob25Ub29sQ2FsbCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvblRvb2xDYWxsKHsgdG9vbENhbGw6IHZhbHVlIH0pO1xuICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBzdG9yZSB0aGUgcmVzdWx0IGluIHRoZSB0b29sIGludm9jYXRpb25cbiAgICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnNbXG4gICAgICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMubGVuZ3RoIC0gMVxuICAgICAgICAgIF0gPSB7IC4uLnZhbHVlLCByZXN1bHQgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3Rvb2xfcmVzdWx0Jykge1xuICAgICAgLy8gY3JlYXRlIG1lc3NhZ2UgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0ID09IG51bGwpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBpZiB0aGVyZSBpcyBhbnkgdG9vbCBpbnZvY2F0aW9uIHdpdGggdGhlIHNhbWUgdG9vbENhbGxJZFxuICAgICAgLy8gYW5kIHJlcGxhY2UgaXQgd2l0aCB0aGUgcmVzdWx0XG4gICAgICBjb25zdCB0b29sSW52b2NhdGlvbkluZGV4ID0gcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zLmZpbmRJbmRleChcbiAgICAgICAgaW52b2NhdGlvbiA9PiBpbnZvY2F0aW9uLnRvb2xDYWxsSWQgPT09IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICApO1xuXG4gICAgICBpZiAodG9vbEludm9jYXRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zW3Rvb2xJbnZvY2F0aW9uSW5kZXhdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2U6IE1lc3NhZ2UgfCBudWxsIHwgdW5kZWZpbmVkID0gbnVsbDtcblxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb25fY2FsbCcpIHtcbiAgICAgIHByZWZpeE1hcFsnZnVuY3Rpb25fY2FsbCddID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogJycsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IHZhbHVlLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIG5hbWU6IHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFsnZnVuY3Rpb25fY2FsbCddO1xuICAgIH1cblxuICAgIGxldCB0b29sQ2FsbE1lc3NhZ2U6IE1lc3NhZ2UgfCBudWxsIHwgdW5kZWZpbmVkID0gbnVsbDtcblxuICAgIGlmICh0eXBlID09PSAndG9vbF9jYWxscycpIHtcbiAgICAgIHByZWZpeE1hcFsndG9vbF9jYWxscyddID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogJycsXG4gICAgICAgIHRvb2xfY2FsbHM6IHZhbHVlLnRvb2xfY2FsbHMsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIH07XG5cbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IHByZWZpeE1hcFsndG9vbF9jYWxscyddO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnZGF0YScpIHtcbiAgICAgIHByZWZpeE1hcFsnZGF0YSddLnB1c2goLi4udmFsdWUpO1xuICAgIH1cblxuICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBwcmVmaXhNYXBbJ3RleHQnXTtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZV9hbm5vdGF0aW9ucycpIHtcbiAgICAgIGlmICghbWVzc2FnZV9hbm5vdGF0aW9ucykge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zID0gWy4uLnZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMucHVzaCguLi52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBhbnkgZXhpc3RpbmcgbWVzc2FnZSB3aXRoIHRoZSBsYXRlc3QgYW5ub3RhdGlvbnNcbiAgICAgIGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwWydmdW5jdGlvbl9jYWxsJ10sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnMsXG4gICAgICApO1xuICAgICAgdG9vbENhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFsndG9vbF9jYWxscyddLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLFxuICAgICAgKTtcbiAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbJ3RleHQnXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8ga2VlcHMgdGhlIHByZWZpeE1hcCB1cCB0byBkYXRlIHdpdGggdGhlIGxhdGVzdCBhbm5vdGF0aW9ucywgZXZlbiBpZiBhbm5vdGF0aW9ucyBwcmVjZWRlZCB0aGUgbWVzc2FnZVxuICAgIGlmIChtZXNzYWdlX2Fubm90YXRpb25zPy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VQcmVmaXhLZXlzOiAoa2V5b2YgUHJlZml4TWFwKVtdID0gW1xuICAgICAgICAndGV4dCcsXG4gICAgICAgICdmdW5jdGlvbl9jYWxsJyxcbiAgICAgICAgJ3Rvb2xfY2FsbHMnLFxuICAgICAgXTtcbiAgICAgIG1lc3NhZ2VQcmVmaXhLZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKHByZWZpeE1hcFtrZXldKSB7XG4gICAgICAgICAgKHByZWZpeE1hcFtrZXldIGFzIE1lc3NhZ2UpLmFubm90YXRpb25zID0gWy4uLm1lc3NhZ2VfYW5ub3RhdGlvbnMhXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2UgYWRkIGZ1bmN0aW9uICYgdG9vbCBjYWxscyBhbmQgcmVzcG9uc2UgbWVzc2FnZXMgdG8gdGhlIG1lc3NhZ2VzW10sIGJ1dCBkYXRhIGlzIGl0cyBvd24gdGhpbmdcbiAgICBjb25zdCBtZXJnZWQgPSBbZnVuY3Rpb25DYWxsTWVzc2FnZSwgdG9vbENhbGxNZXNzYWdlLCByZXNwb25zZU1lc3NhZ2VdXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAubWFwKG1lc3NhZ2UgPT4gKHtcbiAgICAgICAgLi4uYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UobWVzc2FnZSwgbWVzc2FnZV9hbm5vdGF0aW9ucyksXG4gICAgICB9KSkgYXMgTWVzc2FnZVtdO1xuXG4gICAgdXBkYXRlKG1lcmdlZCwgWy4uLnByZWZpeE1hcFsnZGF0YSddXSk7IC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBkYXRhIGFycmF5XG4gIH1cblxuICBvbkZpbmlzaD8uKHByZWZpeE1hcCk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlczogW1xuICAgICAgcHJlZml4TWFwLnRleHQsXG4gICAgICBwcmVmaXhNYXAuZnVuY3Rpb25fY2FsbCxcbiAgICAgIHByZWZpeE1hcC50b29sX2NhbGxzLFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pIGFzIE1lc3NhZ2VbXSxcbiAgICBkYXRhOiBwcmVmaXhNYXAuZGF0YSxcbiAgfTtcbn1cbiIsImltcG9ydCB7XG4gIFN0cmVhbVBhcnRUeXBlLFxuICBTdHJlYW1TdHJpbmdQcmVmaXhlcyxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxufSBmcm9tICcuL3N0cmVhbS1wYXJ0cyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vZ2VuZXJhdGUtaWQnO1xuXG4vLyBUT0RPIHJlbW92ZSAoYnJlYWtpbmcgY2hhbmdlKVxuZXhwb3J0IHsgZ2VuZXJhdGVJZCBhcyBuYW5vaWQgfSBmcm9tICcuL2dlbmVyYXRlLWlkJztcblxuLy8gRXhwb3J0IHN0cmVhbSBkYXRhIHV0aWxpdGllcyBmb3IgY3VzdG9tIHN0cmVhbSBpbXBsZW1lbnRhdGlvbnMsXG4vLyBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlLlxuZXhwb3J0IHR5cGUgeyBTdHJlYW1QYXJ0IH0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuZXhwb3J0IHsgZm9ybWF0U3RyZWFtUGFydCwgcGFyc2VTdHJlYW1QYXJ0IH0gZnJvbSAnLi9zdHJlYW0tcGFydHMnO1xuZXhwb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuL3JlYWQtZGF0YS1zdHJlYW0nO1xuXG4vLyBzaW1wbGUgZGVjb2RlciBzaWduYXR1cmVzOlxuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKCk6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gc3RyaW5nO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKFxuICBjb21wbGV4OiBmYWxzZSxcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gc3RyaW5nO1xuLy8gY29tcGxleCBkZWNvZGVyIHNpZ25hdHVyZTpcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcihcbiAgY29tcGxleDogdHJ1ZSxcbik6IChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkgPT4gU3RyZWFtUGFydFR5cGVbXTtcbi8vIGNvbWJpbmVkIHNpZ25hdHVyZSBmb3Igd2hlbiB0aGUgY2xpZW50IGNhbGxzIHRoaXMgZnVuY3Rpb24gd2l0aCBhIGJvb2xlYW46XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoXG4gIGNvbXBsZXg/OiBib29sZWFuLFxuKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBTdHJlYW1QYXJ0VHlwZVtdIHwgc3RyaW5nO1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKGNvbXBsZXg/OiBib29sZWFuKSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcblxuICBpZiAoIWNvbXBsZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgICAgIGlmICghY2h1bmspIHJldHVybiAnJztcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlclxuICAgICAgLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSlcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5maWx0ZXIobGluZSA9PiBsaW5lICE9PSAnJyk7IC8vIHNwbGl0dGluZyBsZWF2ZXMgYW4gZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmRcblxuICAgIHJldHVybiBkZWNvZGVkLm1hcChwYXJzZVN0cmVhbVBhcnQpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ2h1bmtEZWNvZGVyIH07XG5cbmV4cG9ydCBjb25zdCBpc1N0cmVhbVN0cmluZ0VxdWFsVG9UeXBlID0gKFxuICB0eXBlOiBrZXlvZiB0eXBlb2YgU3RyZWFtU3RyaW5nUHJlZml4ZXMsXG4gIHZhbHVlOiBzdHJpbmcsXG4pOiB2YWx1ZSBpcyBTdHJlYW1TdHJpbmcgPT5cbiAgdmFsdWUuc3RhcnRzV2l0aChgJHtTdHJlYW1TdHJpbmdQcmVmaXhlc1t0eXBlXX06YCkgJiYgdmFsdWUuZW5kc1dpdGgoJ1xcbicpO1xuXG5leHBvcnQgdHlwZSBTdHJlYW1TdHJpbmcgPVxuICBgJHsodHlwZW9mIFN0cmVhbVN0cmluZ1ByZWZpeGVzKVtrZXlvZiB0eXBlb2YgU3RyZWFtU3RyaW5nUHJlZml4ZXNdfToke3N0cmluZ31cXG5gO1xuIiwiaW1wb3J0IHsgcGFyc2VDb21wbGV4UmVzcG9uc2UgfSBmcm9tICcuL3BhcnNlLWNvbXBsZXgtcmVzcG9uc2UnO1xuaW1wb3J0IHsgSWRHZW5lcmF0b3IsIEpTT05WYWx1ZSwgTWVzc2FnZSwgVXNlQ2hhdE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZUNodW5rRGVjb2RlciB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbENoYXRBcGkoe1xuICBhcGksXG4gIG1lc3NhZ2VzLFxuICBib2R5LFxuICBzdHJlYW1Nb2RlID0gJ3N0cmVhbS1kYXRhJyxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGFib3J0Q29udHJvbGxlcixcbiAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlLFxuICBvblJlc3BvbnNlLFxuICBvblVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIG9uVG9vbENhbGwsXG4gIGdlbmVyYXRlSWQsXG59OiB7XG4gIGFwaTogc3RyaW5nO1xuICBtZXNzYWdlczogT21pdDxNZXNzYWdlLCAnaWQnPltdO1xuICBib2R5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBzdHJlYW1Nb2RlPzogJ3N0cmVhbS1kYXRhJyB8ICd0ZXh0JztcbiAgY3JlZGVudGlhbHM/OiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG4gIGhlYWRlcnM/OiBIZWFkZXJzSW5pdDtcbiAgYWJvcnRDb250cm9sbGVyPzogKCkgPT4gQWJvcnRDb250cm9sbGVyIHwgbnVsbDtcbiAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlOiAoKSA9PiB2b2lkO1xuICBvblJlc3BvbnNlPzogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG4gIG9uVXBkYXRlOiAobWVyZ2VkOiBNZXNzYWdlW10sIGRhdGE6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBvbkZpbmlzaD86IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkO1xuICBvblRvb2xDYWxsPzogVXNlQ2hhdE9wdGlvbnNbJ29uVG9vbENhbGwnXTtcbiAgZ2VuZXJhdGVJZDogSWRHZW5lcmF0b3I7XG59KSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbWVzc2FnZXMsXG4gICAgICAuLi5ib2R5LFxuICAgIH0pLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAuLi5oZWFkZXJzLFxuICAgIH0sXG4gICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXI/LigpPy5zaWduYWwsXG4gICAgY3JlZGVudGlhbHMsXG4gIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCk7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcblxuICBpZiAob25SZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgKGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgfHwgJ0ZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS4nLFxuICAgICk7XG4gIH1cblxuICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LicpO1xuICB9XG5cbiAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcblxuICBzd2l0Y2ggKHN0cmVhbU1vZGUpIHtcbiAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuXG4gICAgICBjb25zdCByZXN1bHRNZXNzYWdlID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnIGFzIGNvbnN0LFxuICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgIH07XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRNZXNzYWdlLmNvbnRlbnQgKz0gZGVjb2Rlcih2YWx1ZSk7XG4gICAgICAgIHJlc3VsdE1lc3NhZ2UuaWQgPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gbm90ZTogY3JlYXRpbmcgYSBuZXcgbWVzc2FnZSBvYmplY3QgaXMgcmVxdWlyZWQgZm9yIFNvbGlkLmpzIHN0cmVhbWluZ1xuICAgICAgICBvblVwZGF0ZShbeyAuLi5yZXN1bHRNZXNzYWdlIH1dLCBbXSk7XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCwgc3RvcCByZWFkaW5nIHRoZSBzdHJlYW0uXG4gICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXI/LigpID09PSBudWxsKSB7XG4gICAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uRmluaXNoPy4ocmVzdWx0TWVzc2FnZSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2VzOiBbcmVzdWx0TWVzc2FnZV0sXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlICdzdHJlYW0tZGF0YSc6IHtcbiAgICAgIHJldHVybiBhd2FpdCBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gICAgICAgIHJlYWRlcixcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmOlxuICAgICAgICAgIGFib3J0Q29udHJvbGxlciAhPSBudWxsID8geyBjdXJyZW50OiBhYm9ydENvbnRyb2xsZXIoKSB9IDogdW5kZWZpbmVkLFxuICAgICAgICB1cGRhdGU6IG9uVXBkYXRlLFxuICAgICAgICBvblRvb2xDYWxsLFxuICAgICAgICBvbkZpbmlzaChwcmVmaXhNYXApIHtcbiAgICAgICAgICBpZiAob25GaW5pc2ggJiYgcHJlZml4TWFwLnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgb25GaW5pc2gocHJlZml4TWFwLnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VuZXJhdGVJZCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjazogbmV2ZXIgPSBzdHJlYW1Nb2RlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cmVhbSBtb2RlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENoYXRSZXF1ZXN0LFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgTWVzc2FnZSxcbiAgVG9vbENhbGwsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICBnZXRTdHJlYW1lZFJlc3BvbnNlLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICB1cGRhdGVDaGF0UmVxdWVzdCxcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzLFxufToge1xuICBnZXRTdHJlYW1lZFJlc3BvbnNlOiAoKSA9PiBQcm9taXNlPFxuICAgIE1lc3NhZ2UgfCB7IG1lc3NhZ2VzOiBNZXNzYWdlW107IGRhdGE6IEpTT05WYWx1ZVtdIH1cbiAgPjtcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsPzogKFxuICAgIGNoYXRNZXNzYWdlczogTWVzc2FnZVtdLFxuICAgIGZ1bmN0aW9uQ2FsbDogRnVuY3Rpb25DYWxsLFxuICApID0+IFByb21pc2U8dm9pZCB8IENoYXRSZXF1ZXN0PjtcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGw/OiAoXG4gICAgY2hhdE1lc3NhZ2VzOiBNZXNzYWdlW10sXG4gICAgdG9vbENhbGxzOiBUb29sQ2FsbFtdLFxuICApID0+IFByb21pc2U8dm9pZCB8IENoYXRSZXF1ZXN0PjtcbiAgdXBkYXRlQ2hhdFJlcXVlc3Q6IChjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QpID0+IHZvaWQ7XG4gIGdldEN1cnJlbnRNZXNzYWdlczogKCkgPT4gTWVzc2FnZVtdO1xufSkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFRPRE8tU1RSRUFNREFUQTogVGhpcyBzaG91bGQgYmUgeyAgY29uc3QgeyBtZXNzYWdlczogc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2VzLCBkYXRhIH0gPVxuICAgIC8vIGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UofSBvbmNlIFN0cmVhbSBEYXRhIGlzIG5vdCBleHBlcmltZW50YWxcbiAgICBjb25zdCBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlID0gYXdhaXQgZ2V0U3RyZWFtZWRSZXNwb25zZSgpO1xuXG4gICAgLy8gVXNpbmcgZXhwZXJpbWVudGFsIHN0cmVhbSBkYXRhXG4gICAgaWYgKCdtZXNzYWdlcycgaW4gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSkge1xuICAgICAgbGV0IGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgIC8vIFNlZSBpZiB0aGUgbWVzc2FnZSBoYXMgYSBjb21wbGV0ZSBmdW5jdGlvbiBjYWxsIG9yIHRvb2wgY2FsbFxuICAgICAgICBpZiAoXG4gICAgICAgICAgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAobWVzc2FnZS50b29sX2NhbGxzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlLnRvb2xfY2FsbHMgPT09ICdzdHJpbmcnKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgLy8gVHJ5IHRvIGhhbmRsZSBmdW5jdGlvbiBjYWxsXG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBtZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGZ1bmN0aW9uQ2FsbCBpcyBhbiBvYmplY3RcbiAgICAgICAgICAvLyBJZiBub3QsIHdlIGdvdCB0b29sIGNhbGxzIGluc3RlYWQgb2YgZnVuY3Rpb24gY2FsbHNcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uQ2FsbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29scycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlciBoYW5kbGVzIHRoZSBmdW5jdGlvbiBjYWxsIGluIHRoZWlyIG93biBmdW5jdGlvbkNhbGxIYW5kbGVyLlxuICAgICAgICAgIC8vIFRoZSBcImFyZ3VtZW50c1wiIGtleSBvZiB0aGUgZnVuY3Rpb24gY2FsbCBvYmplY3Qgd2lsbCBzdGlsbCBiZSBhIHN0cmluZyB3aGljaCB3aWxsIGhhdmUgdG8gYmUgcGFyc2VkIGluIHRoZSBmdW5jdGlvbiBoYW5kbGVyLlxuICAgICAgICAgIC8vIElmIHRoZSBcImFyZ3VtZW50c1wiIEpTT04gaXMgbWFsZm9ybWVkIGR1ZSB0byBtb2RlbCBlcnJvciB0aGUgdXNlciB3aWxsIGhhdmUgdG8gaGFuZGxlIHRoYXQgdGhlbXNlbHZlcy5cblxuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlOiBDaGF0UmVxdWVzdCB8IHZvaWQgPVxuICAgICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXMoKSxcbiAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEEgZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3YXMgcmV0dXJuZWQuXG4gICAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gaGFuZGxlIHRvb2wgY2FsbFxuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBtZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRvb2xDYWxscyBpcyBhbiBhcnJheSBvZiBvYmplY3RzXG4gICAgICAgICAgLy8gSWYgbm90LCB3ZSBnb3QgZnVuY3Rpb24gY2FsbHMgaW5zdGVhZCBvZiB0b29sIGNhbGxzXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodG9vbENhbGxzKSB8fFxuICAgICAgICAgICAgdG9vbENhbGxzLnNvbWUodG9vbENhbGwgPT4gdHlwZW9mIHRvb2xDYWxsICE9PSAnb2JqZWN0JylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vblRvb2xDYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2VyIGhhbmRsZXMgdGhlIGZ1bmN0aW9uIGNhbGwgaW4gdGhlaXIgb3duIGZ1bmN0aW9uQ2FsbEhhbmRsZXIuXG4gICAgICAgICAgLy8gVGhlIFwiYXJndW1lbnRzXCIga2V5IG9mIHRoZSBmdW5jdGlvbiBjYWxsIG9iamVjdCB3aWxsIHN0aWxsIGJlIGEgc3RyaW5nIHdoaWNoIHdpbGwgaGF2ZSB0byBiZSBwYXJzZWQgaW4gdGhlIGZ1bmN0aW9uIGhhbmRsZXIuXG4gICAgICAgICAgLy8gSWYgdGhlIFwiYXJndW1lbnRzXCIgSlNPTiBpcyBtYWxmb3JtZWQgZHVlIHRvIG1vZGVsIGVycm9yIHRoZSB1c2VyIHdpbGwgaGF2ZSB0byBoYW5kbGUgdGhhdCB0aGVtc2VsdmVzLlxuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgICBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcblxuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QodG9vbENhbGxSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFzRm9sbG93aW5nUmVzcG9uc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZTtcblxuICAgICAgLy8gVE9ETy1TVFJFQU1EQVRBOiBSZW1vdmUgdGhpcyBvbmNlIFN0cmVhbSBEYXRhIGlzIG5vdCBleHBlcmltZW50YWxcbiAgICAgIGlmIChcbiAgICAgICAgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHR5cGVvZiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHR5cGVvZiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzID09PSAnc3RyaW5nJylcbiAgICAgICkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUgYW5kIGFyZSBleHBlY3RpbmcgYSBmdW5jdGlvbiBjYWxsLCB0aGUgbWVzc2FnZSBzaG91bGQgaGF2ZSBvbmUsIGlmIG5vdCB3YXJuIGFuZCBjb250aW51ZVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICBpZiAoISh0eXBlb2YgZnVuY3Rpb25DYWxsID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlOiBDaGF0UmVxdWVzdCB8IHZvaWQgPVxuICAgICAgICAgIGF3YWl0IGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgZnVuY3Rpb25DYWxsKTtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXMgYSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwsIHRoZSBsb29wIHdpbGwgYnJlYWsuXG4gICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdChmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSBhbmQgYXJlIGV4cGVjdGluZyBhIHRvb2wgY2FsbCwgdGhlIG1lc3NhZ2Ugc2hvdWxkIGhhdmUgb25lLCBpZiBub3Qgd2FybiBhbmQgY29udGludWVcbiAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzO1xuICAgICAgICBpZiAoISh0eXBlb2YgdG9vbENhbGxzID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uVG9vbENhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgZnVuY3Rpb25zJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uVG9vbENhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIHRvb2xDYWxscyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGFzIGEgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLCB0aGUgbG9vcCB3aWxsIGJyZWFrLlxuICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHModG9vbENhbGxSZXNwb25zZSk7XG4gICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMgYXJlIHNlbnQgYmFjayB0byB0aGUgQVBJIGFzIGEgc3RyaW5nXG4gICAgICBmdW5jdGlvbiBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMocmVzcG9uc2U6IENoYXRSZXF1ZXN0KSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiByZXNwb25zZS5tZXNzYWdlcykge1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRvb2xfY2FsbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBtZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sQ2FsbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgJiZcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgIT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJztcbmltcG9ydCB7IGNhbGxDb21wbGV0aW9uQXBpIH0gZnJvbSAnLi4vc2hhcmVkL2NhbGwtY29tcGxldGlvbi1hcGknO1xuaW1wb3J0IHtcbiAgSlNPTlZhbHVlLFxuICBSZXF1ZXN0T3B0aW9ucyxcbiAgVXNlQ29tcGxldGlvbk9wdGlvbnMsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIHsgVXNlQ29tcGxldGlvbk9wdGlvbnMgfTtcblxuZXhwb3J0IHR5cGUgVXNlQ29tcGxldGlvbkhlbHBlcnMgPSB7XG4gIC8qKiBUaGUgY3VycmVudCBjb21wbGV0aW9uIHJlc3VsdCAqL1xuICBjb21wbGV0aW9uOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBTZW5kIGEgbmV3IHByb21wdCB0byB0aGUgQVBJIGVuZHBvaW50IGFuZCB1cGRhdGUgdGhlIGNvbXBsZXRpb24gc3RhdGUuXG4gICAqL1xuICBjb21wbGV0ZTogKFxuICAgIHByb21wdDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucyxcbiAgKSA9PiBQcm9taXNlPHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+O1xuICAvKiogVGhlIGVycm9yIG9iamVjdCBvZiB0aGUgQVBJIHJlcXVlc3QgKi9cbiAgZXJyb3I6IHVuZGVmaW5lZCB8IEVycm9yO1xuICAvKipcbiAgICogQWJvcnQgdGhlIGN1cnJlbnQgQVBJIHJlcXVlc3QgYnV0IGtlZXAgdGhlIGdlbmVyYXRlZCB0b2tlbnMuXG4gICAqL1xuICBzdG9wOiAoKSA9PiB2b2lkO1xuICAvKipcbiAgICogVXBkYXRlIHRoZSBgY29tcGxldGlvbmAgc3RhdGUgbG9jYWxseS5cbiAgICovXG4gIHNldENvbXBsZXRpb246IChjb21wbGV0aW9uOiBzdHJpbmcpID0+IHZvaWQ7XG4gIC8qKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgKi9cbiAgaW5wdXQ6IHN0cmluZztcbiAgLyoqIHNldFN0YXRlLXBvd2VyZWQgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgaW5wdXQgdmFsdWUgKi9cbiAgc2V0SW5wdXQ6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPHN0cmluZz4+O1xuICAvKipcbiAgICogQW4gaW5wdXQvdGV4dGFyZWEtcmVhZHkgb25DaGFuZ2UgaGFuZGxlciB0byBjb250cm9sIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXRcbiAgICogQGV4YW1wbGVcbiAgICogYGBganN4XG4gICAqIDxpbnB1dCBvbkNoYW5nZT17aGFuZGxlSW5wdXRDaGFuZ2V9IHZhbHVlPXtpbnB1dH0gLz5cbiAgICogYGBgXG4gICAqL1xuICBoYW5kbGVJbnB1dENoYW5nZTogKFxuICAgIGU6XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICApID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBGb3JtIHN1Ym1pc3Npb24gaGFuZGxlciB0byBhdXRvbWF0aWNhbGx5IHJlc2V0IGlucHV0IGFuZCBhcHBlbmQgYSB1c2VyIG1lc3NhZ2VcbiAgICogQGV4YW1wbGVcbiAgICogYGBganN4XG4gICAqIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXR9PlxuICAgKiAgPGlucHV0IG9uQ2hhbmdlPXtoYW5kbGVJbnB1dENoYW5nZX0gdmFsdWU9e2lucHV0fSAvPlxuICAgKiA8L2Zvcm0+XG4gICAqIGBgYFxuICAgKi9cbiAgaGFuZGxlU3VibWl0OiAoZTogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4pID0+IHZvaWQ7XG4gIC8qKiBXaGV0aGVyIHRoZSBBUEkgcmVxdWVzdCBpcyBpbiBwcm9ncmVzcyAqL1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIC8qKiBBZGRpdGlvbmFsIGRhdGEgYWRkZWQgb24gdGhlIHNlcnZlciB2aWEgU3RyZWFtRGF0YSAqL1xuICBkYXRhPzogSlNPTlZhbHVlW107XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29tcGxldGlvbih7XG4gIGFwaSA9ICcvYXBpL2NvbXBsZXRpb24nLFxuICBpZCxcbiAgaW5pdGlhbENvbXBsZXRpb24gPSAnJyxcbiAgaW5pdGlhbElucHV0ID0gJycsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBzdHJlYW1Nb2RlLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbn06IFVzZUNvbXBsZXRpb25PcHRpb25zID0ge30pOiBVc2VDb21wbGV0aW9uSGVscGVycyB7XG4gIC8vIEdlbmVyYXRlIGFuIHVuaXF1ZSBpZCBmb3IgdGhlIGNvbXBsZXRpb24gaWYgbm90IHByb3ZpZGVkLlxuICBjb25zdCBob29rSWQgPSB1c2VJZCgpO1xuICBjb25zdCBjb21wbGV0aW9uSWQgPSBpZCB8fCBob29rSWQ7XG5cbiAgLy8gU3RvcmUgdGhlIGNvbXBsZXRpb24gc3RhdGUgaW4gU1dSLCB1c2luZyB0aGUgY29tcGxldGlvbklkIGFzIHRoZSBrZXkgdG8gc2hhcmUgc3RhdGVzLlxuICBjb25zdCB7IGRhdGEsIG11dGF0ZSB9ID0gdXNlU1dSPHN0cmluZz4oW2FwaSwgY29tcGxldGlvbklkXSwgbnVsbCwge1xuICAgIGZhbGxiYWNrRGF0YTogaW5pdGlhbENvbXBsZXRpb24sXG4gIH0pO1xuXG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSPGJvb2xlYW4+KFxuICAgIFtjb21wbGV0aW9uSWQsICdsb2FkaW5nJ10sXG4gICAgbnVsbCxcbiAgKTtcblxuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSPFxuICAgIEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkXG4gID4oW2NvbXBsZXRpb25JZCwgJ3N0cmVhbURhdGEnXSwgbnVsbCk7XG5cbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTx1bmRlZmluZWQgfCBFcnJvcj4odW5kZWZpbmVkKTtcbiAgY29uc3QgY29tcGxldGlvbiA9IGRhdGEhO1xuXG4gIC8vIEFib3J0IGNvbnRyb2xsZXIgdG8gY2FuY2VsIHRoZSBjdXJyZW50IEFQSSBjYWxsLlxuICBjb25zdCBbYWJvcnRDb250cm9sbGVyLCBzZXRBYm9ydENvbnRyb2xsZXJdID1cbiAgICB1c2VTdGF0ZTxBYm9ydENvbnRyb2xsZXIgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHksXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHksXG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG5cbiAgY29uc3QgdHJpZ2dlclJlcXVlc3QgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAocHJvbXB0OiBzdHJpbmcsIG9wdGlvbnM/OiBSZXF1ZXN0T3B0aW9ucykgPT5cbiAgICAgIGNhbGxDb21wbGV0aW9uQXBpKHtcbiAgICAgICAgYXBpLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIGNyZWRlbnRpYWxzOiBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuY3JlZGVudGlhbHMsXG4gICAgICAgIGhlYWRlcnM6IHsgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmhlYWRlcnMsIC4uLm9wdGlvbnM/LmhlYWRlcnMgfSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgICAgIC4uLm9wdGlvbnM/LmJvZHksXG4gICAgICAgIH0sXG4gICAgICAgIHN0cmVhbU1vZGUsXG4gICAgICAgIHNldENvbXBsZXRpb246IGNvbXBsZXRpb24gPT4gbXV0YXRlKGNvbXBsZXRpb24sIGZhbHNlKSxcbiAgICAgICAgc2V0TG9hZGluZzogbXV0YXRlTG9hZGluZyxcbiAgICAgICAgc2V0RXJyb3IsXG4gICAgICAgIHNldEFib3J0Q29udHJvbGxlcixcbiAgICAgICAgb25SZXNwb25zZSxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIG9uRGF0YTogZGF0YSA9PiB7XG4gICAgICAgICAgbXV0YXRlU3RyZWFtRGF0YShbLi4uKHN0cmVhbURhdGEgfHwgW10pLCAuLi4oZGF0YSB8fCBbXSldLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIHN0cmVhbURhdGEsXG4gICAgICBzdHJlYW1Nb2RlLFxuICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICBdLFxuICApO1xuXG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlcikge1xuICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgfVxuICB9LCBbYWJvcnRDb250cm9sbGVyXSk7XG5cbiAgY29uc3Qgc2V0Q29tcGxldGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgIChjb21wbGV0aW9uOiBzdHJpbmcpID0+IHtcbiAgICAgIG11dGF0ZShjb21wbGV0aW9uLCBmYWxzZSk7XG4gICAgfSxcbiAgICBbbXV0YXRlXSxcbiAgKTtcblxuICBjb25zdCBjb21wbGV0ZSA9IHVzZUNhbGxiYWNrPFVzZUNvbXBsZXRpb25IZWxwZXJzWydjb21wbGV0ZSddPihcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QocHJvbXB0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF0sXG4gICk7XG5cbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShpbml0aWFsSW5wdXQpO1xuXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrKFxuICAgIChlOiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PikgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlKGlucHV0KTtcbiAgICB9LFxuICAgIFtpbnB1dCwgY29tcGxldGVdLFxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGU6IGFueSkgPT4ge1xuICAgIHNldElucHV0KGUudGFyZ2V0LnZhbHVlKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNvbXBsZXRpb24sXG4gICAgY29tcGxldGUsXG4gICAgZXJyb3IsXG4gICAgc2V0Q29tcGxldGlvbixcbiAgICBzdG9wLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIGhhbmRsZVN1Ym1pdCxcbiAgICBpc0xvYWRpbmcsXG4gICAgZGF0YTogc3RyZWFtRGF0YSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IHJlYWREYXRhU3RyZWFtIH0gZnJvbSAnLi9yZWFkLWRhdGEtc3RyZWFtJztcbmltcG9ydCB7IEpTT05WYWx1ZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlQ2h1bmtEZWNvZGVyIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxsQ29tcGxldGlvbkFwaSh7XG4gIGFwaSxcbiAgcHJvbXB0LFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgc3RyZWFtTW9kZSA9ICdzdHJlYW0tZGF0YScsXG4gIHNldENvbXBsZXRpb24sXG4gIHNldExvYWRpbmcsXG4gIHNldEVycm9yLFxuICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBvbkRhdGEsXG59OiB7XG4gIGFwaTogc3RyaW5nO1xuICBwcm9tcHQ6IHN0cmluZztcbiAgY3JlZGVudGlhbHM/OiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG4gIGhlYWRlcnM/OiBIZWFkZXJzSW5pdDtcbiAgYm9keTogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgc3RyZWFtTW9kZT86ICdzdHJlYW0tZGF0YScgfCAndGV4dCc7XG4gIHNldENvbXBsZXRpb246IChjb21wbGV0aW9uOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHNldExvYWRpbmc6IChsb2FkaW5nOiBib29sZWFuKSA9PiB2b2lkO1xuICBzZXRFcnJvcjogKGVycm9yOiBFcnJvciB8IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgc2V0QWJvcnRDb250cm9sbGVyOiAoYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIgfCBudWxsKSA9PiB2b2lkO1xuICBvblJlc3BvbnNlPzogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG4gIG9uRmluaXNoPzogKHByb21wdDogc3RyaW5nLCBjb21wbGV0aW9uOiBzdHJpbmcpID0+IHZvaWQ7XG4gIG9uRXJyb3I/OiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkO1xuICBvbkRhdGE/OiAoZGF0YTogSlNPTlZhbHVlW10pID0+IHZvaWQ7XG59KSB7XG4gIHRyeSB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcih1bmRlZmluZWQpO1xuXG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHNldEFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIpO1xuXG4gICAgLy8gRW1wdHkgdGhlIGNvbXBsZXRpb24gaW1tZWRpYXRlbHkuXG4gICAgc2V0Q29tcGxldGlvbignJyk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIC4uLmJvZHksXG4gICAgICB9KSxcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgfSxcbiAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuXG4gICAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgKGF3YWl0IHJlcy50ZXh0KCkpIHx8ICdGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXMuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS4nKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgY29uc3QgcmVhZGVyID0gcmVzLmJvZHkuZ2V0UmVhZGVyKCk7XG5cbiAgICBzd2l0Y2ggKHN0cmVhbU1vZGUpIHtcbiAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY29tcGxldGlvbiBzdGF0ZSB3aXRoIHRoZSBuZXcgbWVzc2FnZSB0b2tlbnMuXG4gICAgICAgICAgcmVzdWx0ICs9IGRlY29kZXIodmFsdWUpO1xuICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcblxuICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQsIHN0b3AgcmVhZGluZyB0aGUgc3RyZWFtLlxuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdzdHJlYW0tZGF0YSc6IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgICAgICAgaXNBYm9ydGVkOiAoKSA9PiBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwsXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdkYXRhJzoge1xuICAgICAgICAgICAgICBvbkRhdGE/Lih2YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2s6IG5ldmVyID0gc3RyZWFtTW9kZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cmVhbSBtb2RlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSWdub3JlIGFib3J0IGVycm9ycyBhcyB0aGV5IGFyZSBleHBlY3RlZC5cbiAgICBpZiAoKGVyciBhcyBhbnkpLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0RXJyb3IoZXJyIGFzIEVycm9yKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3MgKi9cblxuaW1wb3J0IHsgaXNBYm9ydEVycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlci11dGlscyc7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi9zaGFyZWQvZ2VuZXJhdGUtaWQnO1xuaW1wb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuLi9zaGFyZWQvcmVhZC1kYXRhLXN0cmVhbSc7XG5pbXBvcnQge1xuICBBc3Npc3RhbnRTdGF0dXMsXG4gIENyZWF0ZU1lc3NhZ2UsXG4gIE1lc3NhZ2UsXG4gIFVzZUFzc2lzdGFudE9wdGlvbnMsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIFVzZUFzc2lzdGFudEhlbHBlcnMgPSB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBhcnJheSBvZiBjaGF0IG1lc3NhZ2VzLlxuICAgKi9cbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBtZXNzYWdlIHN0b3JlIHdpdGggYSBuZXcgYXJyYXkgb2YgbWVzc2FnZXMuXG4gICAqL1xuICBzZXRNZXNzYWdlczogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248TWVzc2FnZVtdPj47XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHRocmVhZCBJRC5cbiAgICovXG4gIHRocmVhZElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBmaWVsZC5cbiAgICovXG4gIGlucHV0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhIHVzZXIgbWVzc2FnZSB0byB0aGUgY2hhdCBsaXN0LiBUaGlzIHRyaWdnZXJzIHRoZSBBUEkgY2FsbCB0byBmZXRjaFxuICAgKiB0aGUgYXNzaXN0YW50J3MgcmVzcG9uc2UuXG4gICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZFxuICAgKiBAcGFyYW0gcmVxdWVzdE9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSSBjYWxsXG4gICAqL1xuICBhcHBlbmQ6IChcbiAgICBtZXNzYWdlOiBNZXNzYWdlIHwgQ3JlYXRlTWVzc2FnZSxcbiAgICByZXF1ZXN0T3B0aW9ucz86IHtcbiAgICAgIGRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgIH0sXG4gICkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbkFib3J0IHRoZSBjdXJyZW50IHJlcXVlc3QgaW1tZWRpYXRlbHksIGtlZXAgdGhlIGdlbmVyYXRlZCB0b2tlbnMgaWYgYW55LlxuICAgKi9cbiAgc3RvcDogKCkgPT4gdm9pZDtcblxuICAvKipcbiAgICogc2V0U3RhdGUtcG93ZXJlZCBtZXRob2QgdG8gdXBkYXRlIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICovXG4gIHNldElucHV0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PjtcblxuICAvKipcbiAgICogSGFuZGxlciBmb3IgdGhlIGBvbkNoYW5nZWAgZXZlbnQgb2YgdGhlIGlucHV0IGZpZWxkIHRvIGNvbnRyb2wgdGhlIGlucHV0J3MgdmFsdWUuXG4gICAqL1xuICBoYW5kbGVJbnB1dENoYW5nZTogKFxuICAgIGV2ZW50OlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBGb3JtIHN1Ym1pc3Npb24gaGFuZGxlciB0aGF0IGF1dG9tYXRpY2FsbHkgcmVzZXRzIHRoZSBpbnB1dCBmaWVsZCBhbmQgYXBwZW5kcyBhIHVzZXIgbWVzc2FnZS5cbiAgICovXG4gIHN1Ym1pdE1lc3NhZ2U6IChcbiAgICBldmVudD86IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgIHJlcXVlc3RPcHRpb25zPzoge1xuICAgICAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfSxcbiAgKSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIGFzc2lzdGFudC4gVGhpcyBjYW4gYmUgdXNlZCB0byBzaG93IGEgbG9hZGluZyBpbmRpY2F0b3IuXG4gICAqL1xuICBzdGF0dXM6IEFzc2lzdGFudFN0YXR1cztcblxuICAvKipcbiAgICogVGhlIGVycm9yIHRocm93biBkdXJpbmcgdGhlIGFzc2lzdGFudCBtZXNzYWdlIHByb2Nlc3NpbmcsIGlmIGFueS5cbiAgICovXG4gIGVycm9yOiB1bmRlZmluZWQgfCB1bmtub3duO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFzc2lzdGFudCh7XG4gIGFwaSxcbiAgdGhyZWFkSWQ6IHRocmVhZElkUGFyYW0sXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBvbkVycm9yLFxufTogVXNlQXNzaXN0YW50T3B0aW9ucyk6IFVzZUFzc2lzdGFudEhlbHBlcnMge1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPE1lc3NhZ2VbXT4oW10pO1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3RocmVhZElkLCBzZXRUaHJlYWRJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZTxBc3Npc3RhbnRTdGF0dXM+KCdhd2FpdGluZ19tZXNzYWdlJyk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8dW5kZWZpbmVkIHwgRXJyb3I+KHVuZGVmaW5lZCk7XG5cbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoXG4gICAgZXZlbnQ6XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICApID0+IHtcbiAgICBzZXRJbnB1dChldmVudC50YXJnZXQudmFsdWUpO1xuICB9O1xuXG4gIC8vIEFib3J0IGNvbnRyb2xsZXIgdG8gY2FuY2VsIHRoZSBjdXJyZW50IEFQSSBjYWxsLlxuICBjb25zdCBhYm9ydENvbnRyb2xsZXJSZWYgPSB1c2VSZWY8QWJvcnRDb250cm9sbGVyIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LmFib3J0KCk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgY29uc3QgYXBwZW5kID0gYXN5bmMgKFxuICAgIG1lc3NhZ2U6IE1lc3NhZ2UgfCBDcmVhdGVNZXNzYWdlLFxuICAgIHJlcXVlc3RPcHRpb25zPzoge1xuICAgICAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfSxcbiAgKSA9PiB7XG4gICAgc2V0U3RhdHVzKCdpbl9wcm9ncmVzcycpO1xuXG4gICAgc2V0TWVzc2FnZXMobWVzc2FnZXMgPT4gW1xuICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICB7XG4gICAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkID8/IGdlbmVyYXRlSWQoKSxcbiAgICAgIH0sXG4gICAgXSk7XG5cbiAgICBzZXRJbnB1dCgnJyk7XG5cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgICB0cnkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBhYm9ydENvbnRyb2xsZXI7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgY3JlZGVudGlhbHMsXG4gICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCAuLi5oZWFkZXJzIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgIC8vIGFsd2F5cyB1c2UgdXNlci1wcm92aWRlZCB0aHJlYWRJZCB3aGVuIGF2YWlsYWJsZTpcbiAgICAgICAgICB0aHJlYWRJZDogdGhyZWFkSWRQYXJhbSA/PyB0aHJlYWRJZCA/PyBudWxsLFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UuY29udGVudCxcblxuICAgICAgICAgIC8vIG9wdGlvbmFsIHJlcXVlc3QgZGF0YTpcbiAgICAgICAgICBkYXRhOiByZXF1ZXN0T3B0aW9ucz8uZGF0YSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlc3VsdC5ib2R5ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS4nKTtcbiAgICAgIH1cblxuICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0oXG4gICAgICAgIHJlc3VsdC5ib2R5LmdldFJlYWRlcigpLFxuICAgICAgKSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdhc3Npc3RhbnRfbWVzc2FnZSc6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IFtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgcm9sZTogdmFsdWUucm9sZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50WzBdLnRleHQudmFsdWUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAvLyB0ZXh0IGRlbHRhIC0gYWRkIHRvIGxhc3QgbWVzc2FnZTpcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5tZXNzYWdlcy5zbGljZSgwLCBtZXNzYWdlcy5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZDogbGFzdE1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgICByb2xlOiBsYXN0TWVzc2FnZS5yb2xlLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogbGFzdE1lc3NhZ2UuY29udGVudCArIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZGF0YV9tZXNzYWdlJzoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMobWVzc2FnZXMgPT4gW1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZCA/PyBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICAgICAgcm9sZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnOiB7XG4gICAgICAgICAgICBzZXRUaHJlYWRJZCh2YWx1ZS50aHJlYWRJZCk7XG5cbiAgICAgICAgICAgIC8vIHNldCBpZCBvZiBsYXN0IG1lc3NhZ2U6XG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhtZXNzYWdlcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGxhc3RNZXNzYWdlLmlkID0gdmFsdWUubWVzc2FnZUlkO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLm1lc3NhZ2VzLnNsaWNlKDAsIG1lc3NhZ2VzLmxlbmd0aCAtIDEpLCBsYXN0TWVzc2FnZV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICBzZXRFcnJvcihuZXcgRXJyb3IodmFsdWUpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZ25vcmUgYWJvcnQgZXJyb3JzIGFzIHRoZXkgYXJlIGV4cGVjdGVkIHdoZW4gdGhlIHVzZXIgY2FuY2VscyB0aGUgcmVxdWVzdDpcbiAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpICYmIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgc2V0RXJyb3IoZXJyb3IgYXMgRXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBzZXRTdGF0dXMoJ2F3YWl0aW5nX21lc3NhZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc3VibWl0TWVzc2FnZSA9IGFzeW5jIChcbiAgICBldmVudD86IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgIHJlcXVlc3RPcHRpb25zPzoge1xuICAgICAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfSxcbiAgKSA9PiB7XG4gICAgZXZlbnQ/LnByZXZlbnREZWZhdWx0Py4oKTtcblxuICAgIGlmIChpbnB1dCA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhcHBlbmQoeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IGlucHV0IH0sIHJlcXVlc3RPcHRpb25zKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGFwcGVuZCxcbiAgICBtZXNzYWdlcyxcbiAgICBzZXRNZXNzYWdlcyxcbiAgICB0aHJlYWRJZCxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBzdWJtaXRNZXNzYWdlLFxuICAgIHN0YXR1cyxcbiAgICBlcnJvcixcbiAgICBzdG9wLFxuICB9O1xufVxuXG4vKipcbkBkZXByZWNhdGVkIFVzZSBgdXNlQXNzaXN0YW50YCBpbnN0ZWFkLlxuICovXG5leHBvcnQgY29uc3QgZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCA9IHVzZUFzc2lzdGFudDtcbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZUlkIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VTV1IiLCJjdXN0b21BbHBoYWJldCIsImdlbmVyYXRlSWQiLCJ0ZXh0U3RyZWFtUGFydCIsImNvZGUiLCJuYW1lIiwicGFyc2UiLCJ2YWx1ZSIsIkVycm9yIiwidHlwZSIsImZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQiLCJmdW5jdGlvbl9jYWxsIiwiYXJndW1lbnRzIiwiZGF0YVN0cmVhbVBhcnQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvclN0cmVhbVBhcnQiLCJhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCIsImlkIiwicm9sZSIsImNvbnRlbnQiLCJldmVyeSIsIml0ZW0iLCJ0ZXh0IiwiYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0IiwidGhyZWFkSWQiLCJtZXNzYWdlSWQiLCJkYXRhTWVzc2FnZVN0cmVhbVBhcnQiLCJ0b29sQ2FsbHNTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwibWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCIsInRvb2xDYWxsU3RyZWFtUGFydCIsInRvb2xDYWxsSWQiLCJ0b29sTmFtZSIsImFyZ3MiLCJ0b29sUmVzdWx0U3RyZWFtUGFydCIsInN0cmVhbVBhcnRzIiwic3RyZWFtUGFydHNCeUNvZGUiLCJTdHJlYW1TdHJpbmdQcmVmaXhlcyIsInZhbGlkQ29kZXMiLCJtYXAiLCJwYXJ0IiwicGFyc2VTdHJlYW1QYXJ0IiwibGluZSIsImZpcnN0U2VwYXJhdG9ySW5kZXgiLCJpbmRleE9mIiwicHJlZml4Iiwic2xpY2UiLCJpbmNsdWRlcyIsInRleHRWYWx1ZSIsImpzb25WYWx1ZSIsIkpTT04iLCJORVdMSU5FIiwiY2hhckNvZGVBdCIsImNvbmNhdENodW5rcyIsImNodW5rcyIsInRvdGFsTGVuZ3RoIiwiY29uY2F0ZW5hdGVkQ2h1bmtzIiwiVWludDhBcnJheSIsIm9mZnNldCIsImNodW5rIiwic2V0IiwibGVuZ3RoIiwicmVhZERhdGFTdHJlYW0iLCJyZWFkZXIiLCJpc0Fib3J0ZWQiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJyZWFkIiwicHVzaCIsImRlY29kZSIsInN0cmVhbSIsInNwbGl0IiwiZmlsdGVyIiwic3RyZWFtUGFydCIsImNhbmNlbCIsImFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlIiwibWVzc2FnZSIsImFubm90YXRpb25zIiwicGFyc2VDb21wbGV4UmVzcG9uc2UiLCJhYm9ydENvbnRyb2xsZXJSZWYiLCJ1cGRhdGUiLCJvblRvb2xDYWxsIiwib25GaW5pc2giLCJnZXRDdXJyZW50RGF0ZSIsIkRhdGUiLCJjcmVhdGVkQXQiLCJwcmVmaXhNYXAiLCJkYXRhIiwibWVzc2FnZV9hbm5vdGF0aW9ucyIsImN1cnJlbnQiLCJ0b29sSW52b2NhdGlvbnMiLCJyZXN1bHQiLCJ0b29sQ2FsbCIsInRvb2xJbnZvY2F0aW9uSW5kZXgiLCJmaW5kSW5kZXgiLCJpbnZvY2F0aW9uIiwiZnVuY3Rpb25DYWxsTWVzc2FnZSIsInRvb2xDYWxsTWVzc2FnZSIsInJlc3BvbnNlTWVzc2FnZSIsIm1lc3NhZ2VQcmVmaXhLZXlzIiwiZm9yRWFjaCIsImtleSIsIm1lcmdlZCIsIkJvb2xlYW4iLCJtZXNzYWdlcyIsImNyZWF0ZUNodW5rRGVjb2RlciIsImNvbXBsZXgiLCJkZWNvZGVkIiwiY2FsbENoYXRBcGkiLCJhcGkiLCJib2R5Iiwic3RyZWFtTW9kZSIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsImFib3J0Q29udHJvbGxlciIsInJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSIsIm9uUmVzcG9uc2UiLCJvblVwZGF0ZSIsIl9hIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsInN0cmluZ2lmeSIsInNpZ25hbCIsImNhdGNoIiwiZXJyIiwib2siLCJnZXRSZWFkZXIiLCJyZXN1bHRNZXNzYWdlIiwiZG9uZSIsImV4aGF1c3RpdmVDaGVjayIsInByb2Nlc3NDaGF0U3RyZWFtIiwiZ2V0U3RyZWFtZWRSZXNwb25zZSIsImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCIsImV4cGVyaW1lbnRhbF9vblRvb2xDYWxsIiwidXBkYXRlQ2hhdFJlcXVlc3QiLCJnZXRDdXJyZW50TWVzc2FnZXMiLCJtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlIiwiaGFzRm9sbG93aW5nUmVzcG9uc2UiLCJmdW5jdGlvbkNhbGwiLCJjb25zb2xlIiwid2FybiIsImZ1bmN0aW9uQ2FsbFJlc3BvbnNlIiwidG9vbENhbGxzIiwidG9vbENhbGxSZXNwb25zZSIsImZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50cyIsInN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlIiwiY2hhdFJlcXVlc3QiLCJtdXRhdGUiLCJtdXRhdGVTdHJlYW1EYXRhIiwiZXhpc3RpbmdEYXRhIiwiZXh0cmFNZXRhZGF0YVJlZiIsIm1lc3NhZ2VzUmVmIiwic2VuZEV4dHJhTWVzc2FnZUZpZWxkcyIsIl9iIiwicHJldmlvdXNNZXNzYWdlcyIsImNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkIiwidG9vbF9jYWxsX2lkIiwicmVwbHlJZCIsInJlYWRSb3ciLCJwcm9taXNlIiwidWkiLCJuZXh0IiwiZSIsIm9wdGlvbnMiLCJmdW5jdGlvbnMiLCJ0b29scyIsInRvb2xfY2hvaWNlIiwidXNlQ2hhdCIsImluaXRpYWxNZXNzYWdlcyIsImluaXRpYWxJbnB1dCIsImV4cGVyaW1lbnRhbF9tYXhBdXRvbWF0aWNSb3VuZHRyaXBzIiwibWF4QXV0b21hdGljUm91bmR0cmlwcyIsIm1heFRvb2xSb3VuZHRyaXBzIiwib25FcnJvciIsImhvb2tJZCIsImlkS2V5IiwiY2hhdEtleSIsImluaXRpYWxNZXNzYWdlc0ZhbGxiYWNrIiwiZmFsbGJhY2tEYXRhIiwiaXNMb2FkaW5nIiwibXV0YXRlTG9hZGluZyIsInN0cmVhbURhdGEiLCJlcnJvciIsInNldEVycm9yIiwidHJpZ2dlclJlcXVlc3QiLCJBYm9ydENvbnRyb2xsZXIiLCJjaGF0UmVxdWVzdFBhcmFtIiwibGFzdE1lc3NhZ2UiLCJpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzIiwiY291bnRUcmFpbGluZ0Fzc2lzdGFudE1lc3NhZ2VzIiwiYXBwZW5kIiwiY29uY2F0IiwicmVsb2FkIiwic3RvcCIsImFib3J0Iiwic2V0TWVzc2FnZXMiLCJpbnB1dCIsInNldElucHV0IiwiaGFuZGxlU3VibWl0IiwibWV0YWRhdGEiLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZUlucHV0Q2hhbmdlIiwidGFyZ2V0IiwiYWRkVG9vbFJlc3VsdCIsInVwZGF0ZWRNZXNzYWdlcyIsImluZGV4IiwiYXJyIiwidG9vbEludm9jYXRpb24iLCJleHBlcmltZW50YWxfYWRkVG9vbFJlc3VsdCIsImNvdW50IiwiaSIsImNhbGxDb21wbGV0aW9uQXBpIiwicHJvbXB0Iiwic2V0Q29tcGxldGlvbiIsInNldExvYWRpbmciLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJvbkRhdGEiLCJyZXMiLCJ1c2VDb21wbGV0aW9uIiwiaW5pdGlhbENvbXBsZXRpb24iLCJjb21wbGV0aW9uSWQiLCJjb21wbGV0aW9uIiwiY29tcGxldGUiLCJpc0Fib3J0RXJyb3IiLCJ1c2VBc3Npc3RhbnQiLCJ0aHJlYWRJZFBhcmFtIiwic2V0VGhyZWFkSWQiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJldmVudCIsInJlcXVlc3RPcHRpb25zIiwiYWJvcnRlZCIsInN1Ym1pdE1lc3NhZ2UiLCJjYWxsIiwiZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ })

};
;